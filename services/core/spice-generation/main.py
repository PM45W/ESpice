from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn
import os
from datetime import datetime
import json
from typing import Dict, List, Optional, Any
from pydantic import BaseModel
import re

# Create FastAPI app
app = FastAPI(
    title="ESpice SPICE Service",
    description="Microservice for SPICE model generation and parameter fitting",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request/response
class SPICEGenerationRequest(BaseModel):
    device_name: str
    device_type: str
    model_type: str
    parameters: Optional[Dict[str, Any]] = None
    extracted_data: Optional[Dict[str, Any]] = None

class ParameterFittingRequest(BaseModel):
    extracted_data: Dict[str, Any]
    model_type: str
    optimization_method: str = "least_squares"

class ModelValidationRequest(BaseModel):
    model_text: str
    model_type: str
    validation_rules: Optional[Dict[str, Any]] = None

class ModelExportRequest(BaseModel):
    model_text: str
    export_format: str = "generic"  # generic, ltspice, kicad, ads
    include_comments: bool = True

class ServiceResponse(BaseModel):
    success: bool
    data: Optional[Dict] = None
    error: Optional[str] = None
    metadata: Dict[str, Any]

def create_metadata(processing_time: float, service: str = "spice-service") -> Dict[str, Any]:
    """Create standardized metadata for service responses"""
    return {
        "processingTime": processing_time,
        "service": service,
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat()
    }

# SPICE Model Templates
SPICE_MODELS = {
    "asm_hemt": {
        "name": "ASM-HEMT",
        "description": "Advanced SPICE Model for GaN HEMT devices",
        "template": """
.SUBCKT {device_name} D G S
* ASM-HEMT Model for {device_name}
* Generated by ESpice SPICE Service
* Device Type: {device_type}
* Parameters: {parameters}

* Zero-volt voltage source to sense drain current
VDsense D Dint 0

* Source resistance
RS Sint S {{{rs_nom}*(1+{krsc}*(TEMP-25))}}

* Drain resistance (non-linear)
G_RD Dint D VALUE={{I(VDsense) * {rd0} * (1 + (V(Dint,Sint)/{vsat})**{mexp_accs_d})}}

* High-value resistor to prevent floating Gint
Rgint Gint 0 1G

* V_GS-dependent VDSAT (smoothed)
BVDSAT VDSAT_node 0 V={{MAX(0.3, 0.5 + 0.3*(V(G,S)-{voff}))}}

* Drain current
GId Dint Sint VALUE={{IF(V(G,S)>{voff}, {kp}*(V(G,S)-{voff})**{vse}*(1 + ({lambda0} + {lambda1}*(V(G,S)-{voff}))*V(Dint,Sint))*TANH(V(Dint,Sint)/V(VDSAT_node)), 0)}}

* Capacitances
B_CGD Gint Dint I={{{cgdo} * exp(-{kcap_cgdo} * (V(Dint,Sint)/{vdsatcv})) * ddt(V(Gint,Dint))}}
B_CGS Gint Sint I={{{cgso} * exp(-{kcap_cgso} * (V(Gint,S) - {voff})) * ddt(V(Gint,Sint))}}
B_CDS Dint Sint I={{{cdso} * exp(-{kcap_cdso} * (V(Dint,Sint)/{vdsatcv})) * ddt(V(Dint,Sint))}}

* Thermal resistance and capacitance
Rth Tnode 0 {{{rth0}}}
Cth Tnode 0 1u

* Parameters
.PARAM MEXP_ACCS_D={mexp_accs_d}
.PARAM RD0={rd0}
.PARAM VSAT={vsat}
.PARAM VDSATCV={vdsatcv}
.PARAM RSnom={rs_nom}
.PARAM LAMBDA0={lambda0}
.PARAM LAMBDA1={lambda1}
.PARAM VSE={vse}
.PARAM CGDO={cgdo}
.PARAM CGSO={cgso}
.PARAM CDSO={cdso}
.PARAM KRSC={krsc}
.PARAM KRDC={krsc}
.PARAM VOFF0={voff}
.PARAM KVTO={kvto}
.PARAM VOFF={{{voff} + {kvto}*(TEMP - 25)}}
.PARAM RTH0={rth0}
.PARAM KPnom={kp}
.PARAM UTE={ute}
.PARAM KP={{{kp}*((TEMP/25)**{ute})}}
.PARAM KCAP_CGSO={kcap_cgso}
.PARAM KCAP_CGDO={kcap_cgdo}
.PARAM KCAP_CDSO={kcap_cdso}

.ENDS {device_name}
""",
        "default_parameters": {
            "mexp_accs_d": 0.34,
            "rd0": "12m",
            "vsat": 1.0,
            "vdsatcv": 2.5,
            "rs_nom": "12m",
            "lambda0": 0.05,
            "lambda1": 0.015,
            "vse": 1.73,
            "cgdo": "25.8p",
            "cgso": "90.344p",
            "cdso": "72.905p",
            "krsc": "6.0014e-3",
            "voff": 1.9,
            "kvto": "-1.2938e-3",
            "rth0": "5.946e2",
            "kp": 10.0,
            "ute": -0.35,
            "kcap_cgso": 0.0226,
            "kcap_cgdo": 0.0994,
            "kcap_cdso": 0.037
        }
    },
    "mvsg": {
        "name": "MVSG",
        "description": "Multi-Version Surface Potential Model for SiC MOSFET",
        "template": """
.SUBCKT {device_name} D G S
* MVSG Model for {device_name}
* Generated by ESpice SPICE Service
* Device Type: {device_type}
* Parameters: {parameters}

* Drain current model
GId D S VALUE={{IF(V(G,S)>{vth}, {mu}*{cox}*{w}/{l}*((V(G,S)-{vth})*V(D,S)-0.5*V(D,S)**2)*(1+{lambda}*V(D,S)), 0)}}

* Gate current
Ig G S VALUE={{IF(V(G,S)>{vth}, {is}*(exp(V(G,S)/({n}*0.026))-1), 0)}}

* Capacitances
Cgd D G {{{cgd}}}
Cgs G S {{{cgs}}}
Cds D S {{{cds}}}

* Parameters
.PARAM VTH={vth}
.PARAM MU={mu}
.PARAM COX={cox}
.PARAM W={w}
.PARAM L={l}
.PARAM LAMBDA={lambda}
.PARAM IS={is}
.PARAM N={n}
.PARAM CGD={cgd}
.PARAM CGS={cgs}
.PARAM CDS={cds}

.ENDS {device_name}
""",
        "default_parameters": {
            "vth": 2.5,
            "mu": 600,
            "cox": "1e-6",
            "w": "1e-3",
            "l": "1e-6",
            "lambda": 0.01,
            "is": "1e-12",
            "n": 1.5,
            "cgd": "0.1p",
            "cgs": "0.1p",
            "cds": "0.1p"
        }
    },
    "si_mosfet": {
        "name": "Si-MOSFET",
        "description": "Standard Silicon MOSFET Model",
        "template": """
.SUBCKT {device_name} D G S
* Si-MOSFET Model for {device_name}
* Generated by ESpice SPICE Service
* Device Type: {device_type}
* Parameters: {parameters}

* Drain current (Level 1 model)
GId D S VALUE={{IF(V(G,S)>{vto}, {kp}*{w}/{l}*((V(G,S)-{vto})*V(D,S)-0.5*V(D,S)**2)*(1+{lambda}*V(D,S)), 0)}}

* Gate current
Ig G S VALUE={{IF(V(G,S)>{vto}, {is}*(exp(V(G,S)/({n}*0.026))-1), 0)}}

* Capacitances
Cgd D G {{{cgd}}}
Cgs G S {{{cgs}}}
Cds D S {{{cds}}}

* Parameters
.PARAM VTO={vto}
.PARAM KP={kp}
.PARAM W={w}
.PARAM L={l}
.PARAM LAMBDA={lambda}
.PARAM IS={is}
.PARAM N={n}
.PARAM CGD={cgd}
.PARAM CGS={cgs}
.PARAM CDS={cds}

.ENDS {device_name}
""",
        "default_parameters": {
            "vto": 1.0,
            "kp": 50.0,
            "w": "1e-3",
            "l": "1e-6",
            "lambda": 0.01,
            "is": "1e-12",
            "n": 1.5,
            "cgd": "0.1p",
            "cgs": "0.1p",
            "cds": "0.1p"
        }
    }
}

def generate_spice_model(
    device_name: str,
    device_type: str,
    model_type: str,
    parameters: Optional[Dict[str, Any]] = None,
    extracted_data: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Generate SPICE model from parameters and extracted data"""
    try:
        if model_type not in SPICE_MODELS:
            raise ValueError(f"Unsupported model type: {model_type}")
        
        model_info = SPICE_MODELS[model_type]
        
        # Use provided parameters or default parameters
        if parameters:
            model_params = parameters
        else:
            model_params = model_info["default_parameters"].copy()
        
        # Fit parameters from extracted data if available
        if extracted_data:
            fitted_params = fit_parameters_from_data(extracted_data, model_type)
            model_params.update(fitted_params)
        
        # Generate model text
        model_text = model_info["template"].format(
            device_name=device_name,
            device_type=device_type,
            parameters=json.dumps(model_params, indent=2)
        )
        
        return {
            "model_text": model_text,
            "model_type": model_type,
            "device_name": device_name,
            "device_type": device_type,
            "parameters": model_params,
            "model_info": {
                "name": model_info["name"],
                "description": model_info["description"]
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating SPICE model: {str(e)}")

def fit_parameters_from_data(extracted_data: Dict[str, Any], model_type: str) -> Dict[str, Any]:
    """Fit parameters from extracted datasheet data"""
    try:
        fitted_params = {}
        
        if "parameters" in extracted_data:
            params = extracted_data["parameters"]
            
            # Fit threshold voltage
            if "v_th" in params:
                if model_type == "asm_hemt":
                    fitted_params["voff"] = params["v_th"]
                elif model_type == "mvsg":
                    fitted_params["vth"] = params["v_th"]
                elif model_type == "si_mosfet":
                    fitted_params["vto"] = params["v_th"]
            
            # Fit on-resistance
            if "r_ds_on" in params:
                r_ds_on = params["r_ds_on"]
                if model_type == "asm_hemt":
                    fitted_params["rd0"] = f"{r_ds_on/2}m"  # Split between source and drain
                    fitted_params["rs_nom"] = f"{r_ds_on/2}m"
                elif model_type in ["mvsg", "si_mosfet"]:
                    # Calculate mobility from R_DS(on)
                    fitted_params["mu"] = 1.0 / (r_ds_on * 1e-3)  # Simplified calculation
            
            # Fit capacitances
            if "c_iss" in params:
                if model_type == "asm_hemt":
                    fitted_params["cgso"] = f"{params['c_iss']}p"
                elif model_type in ["mvsg", "si_mosfet"]:
                    fitted_params["cgs"] = f"{params['c_iss']}p"
            
            if "c_oss" in params:
                if model_type == "asm_hemt":
                    fitted_params["cdso"] = f"{params['c_oss']}p"
                elif model_type in ["mvsg", "si_mosfet"]:
                    fitted_params["cds"] = f"{params['c_oss']}p"
            
            if "c_rss" in params:
                if model_type == "asm_hemt":
                    fitted_params["cgdo"] = f"{params['c_rss']}p"
                elif model_type in ["mvsg", "si_mosfet"]:
                    fitted_params["cgd"] = f"{params['c_rss']}p"
        
        return fitted_params
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fitting parameters: {str(e)}")

def validate_spice_model(model_text: str, model_type: str, validation_rules: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """Validate generated SPICE model"""
    try:
        validation_results = {
            "syntax_valid": True,
            "structure_valid": True,
            "parameters_valid": True,
            "warnings": [],
            "errors": [],
            "validation_score": 1.0
        }
        
        # Basic syntax validation
        if not model_text.strip():
            validation_results["syntax_valid"] = False
            validation_results["errors"].append("Model text is empty")
        
        # Check for required SPICE elements
        required_elements = [".SUBCKT", ".ENDS"]
        for element in required_elements:
            if element not in model_text:
                validation_results["structure_valid"] = False
                validation_results["errors"].append(f"Missing required element: {element}")
        
        # Check for device name consistency
        subckt_match = re.search(r'\.SUBCKT\s+(\w+)', model_text)
        ends_match = re.search(r'\.ENDS\s+(\w+)', model_text)
        
        if subckt_match and ends_match:
            subckt_name = subckt_match.group(1)
            ends_name = ends_match.group(1)
            if subckt_name != ends_name:
                validation_results["structure_valid"] = False
                validation_results["errors"].append("Device name mismatch between .SUBCKT and .ENDS")
        
        # Check for parameter definitions
        if ".PARAM" not in model_text:
            validation_results["warnings"].append("No parameter definitions found")
        
        # Calculate validation score
        error_count = len(validation_results["errors"])
        warning_count = len(validation_results["warnings"])
        
        if error_count > 0:
            validation_results["validation_score"] = 0.0
        elif warning_count > 0:
            validation_results["validation_score"] = 0.8
        
        return validation_results
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error validating SPICE model: {str(e)}")

def export_model(model_text: str, export_format: str = "generic", include_comments: bool = True) -> Dict[str, Any]:
    """Export SPICE model in different formats"""
    try:
        if export_format == "generic":
            # Generic SPICE format (already in correct format)
            exported_text = model_text
        
        elif export_format == "ltspice":
            # LTspice format - add LTspice-specific comments
            exported_text = "* LTspice SPICE Model\n"
            exported_text += "* Generated by ESpice SPICE Service\n"
            exported_text += "* Format: LTspice\n\n"
            exported_text += model_text
        
        elif export_format == "kicad":
            # KiCad format - add KiCad-specific header
            exported_text = "# KiCad SPICE Model\n"
            exported_text += "# Generated by ESpice SPICE Service\n"
            exported_text += "# Format: KiCad\n\n"
            exported_text += model_text
        
        elif export_format == "ads":
            # ADS format - convert to ADS syntax
            exported_text = "// ADS SPICE Model\n"
            exported_text += "// Generated by ESpice SPICE Service\n"
            exported_text += "// Format: ADS\n\n"
            # Convert SPICE syntax to ADS syntax
            ads_text = model_text.replace(".SUBCKT", "subckt")
            ads_text = ads_text.replace(".ENDS", "ends")
            ads_text = ads_text.replace(".PARAM", "param")
            exported_text += ads_text
        
        else:
            raise ValueError(f"Unsupported export format: {export_format}")
        
        return {
            "exported_text": exported_text,
            "export_format": export_format,
            "include_comments": include_comments,
            "text_length": len(exported_text)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error exporting model: {str(e)}")

# API Endpoints
@app.get("/")
async def root():
    """Root endpoint"""
    return {"message": "ESpice SPICE Service", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "spice-service",
        "timestamp": datetime.utcnow().isoformat()
    }

@app.get("/api/spice/models")
async def get_available_models():
    """Get available SPICE model types"""
    models = []
    for model_type, model_info in SPICE_MODELS.items():
        models.append({
            "type": model_type,
            "name": model_info["name"],
            "description": model_info["description"]
        })
    
    return ServiceResponse(
        success=True,
        data={"models": models},
        metadata=create_metadata(0.0)
    )

@app.post("/api/spice/generate-model")
async def generate_model(request: SPICEGenerationRequest):
    """Generate SPICE model"""
    start_time = datetime.now()
    
    try:
        result = generate_spice_model(
            device_name=request.device_name,
            device_type=request.device_type,
            model_type=request.model_type,
            parameters=request.parameters,
            extracted_data=request.extracted_data
        )
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return ServiceResponse(
            success=True,
            data=result,
            metadata=create_metadata(processing_time)
        )
    except Exception as e:
        processing_time = (datetime.now() - start_time).total_seconds()
        return ServiceResponse(
            success=False,
            error=str(e),
            metadata=create_metadata(processing_time)
        )

@app.post("/api/spice/fit-parameters")
async def fit_parameters(request: ParameterFittingRequest):
    """Fit parameters from extracted data"""
    start_time = datetime.now()
    
    try:
        result = fit_parameters_from_data(
            request.extracted_data,
            request.model_type
        )
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return ServiceResponse(
            success=True,
            data={
                "fitted_parameters": result,
                "model_type": request.model_type,
                "optimization_method": request.optimization_method
            },
            metadata=create_metadata(processing_time)
        )
    except Exception as e:
        processing_time = (datetime.now() - start_time).total_seconds()
        return ServiceResponse(
            success=False,
            error=str(e),
            metadata=create_metadata(processing_time)
        )

@app.post("/api/spice/validate-model")
async def validate_model(request: ModelValidationRequest):
    """Validate SPICE model"""
    start_time = datetime.now()
    
    try:
        result = validate_spice_model(
            model_text=request.model_text,
            model_type=request.model_type,
            validation_rules=request.validation_rules
        )
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return ServiceResponse(
            success=True,
            data=result,
            metadata=create_metadata(processing_time)
        )
    except Exception as e:
        processing_time = (datetime.now() - start_time).total_seconds()
        return ServiceResponse(
            success=False,
            error=str(e),
            metadata=create_metadata(processing_time)
        )

@app.post("/api/spice/export-model")
async def export_model_endpoint(request: ModelExportRequest):
    """Export SPICE model in different formats"""
    start_time = datetime.now()
    
    try:
        result = export_model(
            model_text=request.model_text,
            export_format=request.export_format,
            include_comments=request.include_comments
        )
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return ServiceResponse(
            success=True,
            data=result,
            metadata=create_metadata(processing_time)
        )
    except Exception as e:
        processing_time = (datetime.now() - start_time).total_seconds()
        return ServiceResponse(
            success=False,
            error=str(e),
            metadata=create_metadata(processing_time)
        )

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8005) 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Copyright 2024 Ujwal Radhakrishna and Lan Wei
//Copyright 2023 Ujwal Radhakrishna and Lan Wei
//Copyright 2022 Ujwal Radhakrishna and Lan Wei
//Copyright 2021 Ujwal Radhakrishna and Lan Wei
//Copyright 2021 Massachusetts Institute of Technology
//Copyright 2020 Ujwal Radhakrishna and Lan Wei
//Copyright 2020 Massachusetts Institute of Technology
//Copyright 2019 Ujwal Radhakrishna and Lan Wei
//Copyright 2019 Massachusetts Institute of Technology
//Copyright 2018 Ujwal Radhakrishna, Dimitri Antoniadis and Lan Wei
//Copyright 2018 Massachusetts Institute of Technology
//Copyright 2017 Massachusetts Institute of Technology
//
//Licensed under the Educational Community License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://opensource.org/licenses/ECL-2.0
//
//Unless required by applicable law or agreed to in writing, software distributed under the
//License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//KIND, either express or implied. See the License for the specific language governing
//permissions and limitations under the License.
//
//
//The MVSG_CMC standard has been supported by the members of Silicon Integration Initiativeâ€™s
//Compact Model Coalition. A link to the most recent version of this standard can be found at:
//
//http://www.si2.org/cmc
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// VerilogA for MVSG_CMC GaN HEMT model based self-consistent transport/capacitance models for HV and RF applications
// Model details:  U. Radhakrishna, et al, IEDM 2013.
// Implemented on 8/06/2015, 2015 by U. Radhakrishna
// The model was originally developed under the supervision of Prof. Dimitri Antoniadis (MIT). U. Radhakrishna and L. Wei sincerely appreciate Prof. Antoniadis' mentorship, guidance and support.
//
// Updates in v4.0.0 official release
// 1. Updated p-GaN module:
//   i. high injection, reverse recombination voltage saturation, secondary reverse recombination
//   ii. p-GaN Ohmic junction added
//   iii. New implementation of pGaN capacitance to ensure charge conservation
//   iv.  pGaN charge/capacitance and ohmic junction resistance branch direction swapped to match with pGaN diode
//   v. Adjusted order and values of pGaN parameters so curves match that of gate leakage

// 2. Smoothing function update:
//   i. Added additional input to mmax and absfunc to allow for adjustment of smoothing strength
//   ii. Added new parameter "mmaxs" as default value of mmax/absfunc smoothing value which was previously hardcoded to be 4.0 * 1e-5

// 3. Replace if-statements for computing vsars and vdars with mmax function to remove discontinuities in derivatives of SAR and DAR currents if flaggum=1
// 4. Rewrote high injection formulation in calc_ig to ensure better physical accuracy and ease of modeling

// 5. Noise calculations for gate diodes updated to include gate current debiasing
// 6. Fixed internal node tie off when trapselect = 1 or 2
// 7. Fixed calc_capt function returning output value twice
// 8. Removed one nested layer from explim function (functionality is unchanged)

// 9. Parameter definition/description minor updates:
//   i. Updated to allow minr to be 0 to comply with new issued guidelines
//   ii. Gate leakage parameters reorganized for better functional grouping
//   iii. Changed csh0 parameter from oz to cz to allow disabling of charge effects
//   iv. Updated version parameter
//   v. Initilized some local variables to zero
//   vi. Some local variables renamed
//   vii. Updated smoothing function implementation
//   viii. New macro added for model parameters for two closed end values "MPRcc"
//   ix. Changed some parameters from co to cc
//   x. Updated rcapture and remission parameter descriptions for clarity

//********Version number: 4.0.0officialrelease*************//

`include "disciplines.vams"
`include "constants.vams"

// Physical constants
`define P_KK           (1.38062e-23)
`define P_QQ           (1.60219e-19)
`define T_MAX          (1500)
`define T_MIN          (-270.0)

// Mathematical Constants
`define M_MAXEXP       (50.0)

// Define macros for parameters
`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def;
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr);
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr];
`define MPRcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from(  0:inf);
`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1];
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0;
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr);
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr];
`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def;
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(  0:inf);
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr);

// Define macros for OP-points
`define OPP(nam,uni,des)               (* desc=des, units=uni *)                           real    nam;
`define OPM(nam,uni,des)               (* desc=des, units=uni, multiplicity="multiply" *)  real    nam;
`define OPD(nam,uni,des)               (* desc=des, units=uni, multiplicity="divide"   *)  real    nam;

module mvsg_cmc (d, g, s, b, dt);

inout d, g, s, b, dt;
electrical d, g, s, b;
electrical di, gi1, gi2, gi2p, si, fps1, fps2, fps3, fps4, fp1, fp2, fp3, fp4, drc, src;
electrical tr, tr1, dtrapin, dtrapin2, dtrapin3, gtrapin, gtrapin2, gtrapin3;
electrical xt1, xt2;
thermal dt;

// Parameter definition
// Instance parameters
`IPRoz(w,        180.0e-6, "m",       "Width per Finger")
`IPRoz(l,        250.0e-9, "m",       "Effective gate length")
`IPIco(ngf,      1,        "", 1, inf,"Number of Fingers")
`IPRnb(dtemp,    0.0,      "K",       "Device temperature offset from ambient")

// Model parameters
`MPRcz(version,  4.00,     "",        "Version number")
`MPRco(tnom,     27.0,     "deg C", -273.15, inf, "Reference temperature for the model")
`MPIty(type,     1,        "",        "nFET=1 pFET=-1")
`MPRoz(cg,       4.00e-03, "F/m^2",   "Gate cap/area")
`MPRnb(tcg,      0.0,      "1/K",     "cg dependence on temperature")
`MPRcz(cofsm,    0.0,      "F/m",     "Gate - Source outer fringing cap/width (bias-dependent component)")
`MPRcz(cofdm,    0.0,      "F/m",     "Gate - Drain outer fringing cap/width (bias-dependent component)")
`MPRcz(cofdsm,   0.0,      "F/m",     "Source - Drain outer fringing cap/width (bias-dependent component)")
`MPRcz(cofdsubm, 0.0,      "F/m",     "Sub - Drain outer fringing cap/width (bias-dependent component)")
`MPRcz(cofssubm, 0.0,      "F/m",     "Sub - Source outer fringing cap/width (bias-dependent component)")
`MPRcz(cofgsubm, 0.0,      "F/m",     "Sub - Gate outer fringing cap/width (bias-dependent component)")
`MPRcz(cofsm0,   0.0,      "F/m",     "Gate - Source outer fringing cap/width (bias-independent component)")
`MPRcz(cofdm0,   0.0,      "F/m",     "Gate - Drain outer fringing cap/width (bias-independent component)")
`MPRcz(cofdsm0,  0.0,      "F/m",     "Source - Drain outer fringing cap/width (bias-independent component)")
`MPRcz(cofdsubm0,0.0,      "F/m",     "Sub - Drain outer fringing cap/width (bias-independent component)")
`MPRcz(cofssubm0,0.0,      "F/m",     "Sub - Source outer fringing cap/width (bias-independent component)")
`MPRcz(cofgsubm0,0.0,      "F/m",     "Sub - Gate outer fringing cap/width (bias-independent component)")
`MPRnb(tcofs,    0.0,      "1/K",     "cofs dependence on temperature")
`MPRnb(tcofd,    0.0,      "1/K",     "cofd dependence on temperature")
`MPRnb(tcofds,   0.0,      "1/K",     "cofds dependence on temperature")
`MPRnb(tcofssub, 0.0,      "1/K",     "cofssub dependence on temperature")
`MPRnb(tcofdsub, 0.0,      "1/K",     "cofdsub dependence on temperature")
`MPRnb(tcofgsub, 0.0,      "1/K",     "cofgsub dependence on temperature")
`MPRnb(vtfrin,   -50,      "V",       "Threshold voltage for fringing fields")
`MPRoz(nfrin,    1e2,      "V",       "Fringing capacitance's V-dependent slope, NOTE: Make sure it is larger than 65mV/decade")
`MPRoz(rsh,      150.0,    "Ohms/Sq", "2-DEG Sheet Resistance")
`MPRcz(rcs,      800e-6,   "Ohms*m",  "Source contact resistance * Width")
`MPRcz(rcd,      800e-6,   "Ohms*m",  "Drain contact resistance * Width")
`MPRoz(vx0,      3.0e5,    "m/s",     "Source injection velocity")
`MPRoz(mu0,      0.135,    "m^2/Vs",  "Low-field mobility")
`MPRoz(beta,     2.0,      "",        "Linear to saturation parameter, NOTE: Users who want differentiability should use even beta")
`MPRnb(vto,      -2.72,    "V",       "Threshold voltage")
`MPRoz(ss,       0.120,    "V/dec",   "Sub-threshold slope")
`MPRcz(delta1,   16e-3,    "",        "DIBL Coefficient 1")
`MPRcz(delta2,   0.0,      "",        "DIBL Coefficient 2")
`MPRcz(dibsat,   10.0,     "V",       "DIBL saturation Voltage")
`MPRcz(nd,       0.0,      "",        "Punchthrough factor for subth slope")
`MPRoz(alpha,    3.5,      "",        "Weak to strong inversion transition factor, NOTE: alpha should scale up linearly with ss: alpha=3.5 for ss=65mV/dec")
`MPRcz(lambda,   0.0,      "1/V",     "CLM parameter")
`MPRcz(vtheta,   0.0,      "1/V",     "Scattering: velocity reduction parameter with Vg")
`MPRcz(mtheta,   0.0,      "1/V",     "Scattering: mobility reduction parameter with Vg")
`MPRcz(vzeta,    150e3,    "1/K",     "vx0 dependence on temperature")
`MPRnb(vtzeta,   -0.4e-3,  "V/K",     "vto dependence on temperature")
`MPRcz(epsilon,  2.3,      "",        "Mobility dependence on temperature")
`MPRnb(rct1,     0.0,      "1/K",     "Linear Rsh and Rc temperature coefficient")
`MPRnb(rct2,     0.0,      "1/K^2",   "Quadratic Rsh and Rc temperature coefficient")

`MPIsw(flagres,  0,        "",        "Flag parameter for resistor: resistor is chosen if flagres=1 or implicit transistor is chosen if flagres=0")
`MPIsw(flagsp,   0,        "",        "Flag parameter for VT-shift with surface potential: flagsp=0 by default turns it off (robust), flagsp=1 turns it on (possibility to have kinks in charge at certain parameter sets)")
`MPIsw(flaggum,  0,        "",        "Flag parameter for smoothing function in absfunc and mmax: xtanhx smoothing function used if flaggum=1 or original implementation if flaggum=0, source voltage of SAR and DAR uses xtanhx if flaggum=1 or original piecewise if flaggum=0")
`MPRcz(mmaxs,    4.0e-5,   "",        "Parameter to control how much smoothing in majority of function calls to mmax and absfunc")

// Source access region parameters
`MPRcz(lgs,      3.0e-6,   "m",       "Source access region (SAR) length parameter")
`MPRnb(vtors,    -650,     "V",       "SAR threshold voltage")
`MPRoz(cgrs,     5.0e-3,   "F/m^2",   "SAR gate-cap/area")
`MPRoz(vx0rs,    100e3,    "m/s",     "SAR source injection velocity")
`MPRoz(mu0rs,    100e-3,   "m^2/Vs",  "SAR low-field mobility")
`MPRoz(betars,   1.00,     "",        "SAR linear to saturation parameter")
`MPRcz(delta1rs, 100e-3,   "",        "SAR DIBL Coefficient")
`MPRoz(srs,      0.100,    "V/dec",   "SAR Sub-threshold slope")
`MPRcz(ndrs,     0.0,      "",        "SAR punchthrough factor for subth slope")
`MPRcz(vthetars, 0.0,      "1/V",     "SAR scattering: velocity reduction parameter with Vg")
`MPRcz(mthetars, 0.0,      "1/V",     "SAR scattering: mobility reduction parameter with Vg")
`MPRoz(alphars,  3.5,      "",        "SAR weak to strong inversion transition factor, NOTE: alphars should scale up linearly with srs: alphrs=3.5 for srs=65mV/dec")

// Drain access region parameters
`MPRcz(lgd,      4.85e-6,  "m",       "Drain access region (DAR) length parameter")
`MPRnb(vtord,    -650,     "V",       "DAR threshold voltage")
`MPRoz(cgrd,     4.3e-3,   "F/m^2",   "DAR gate-cap/area")
`MPRoz(vx0rd,    100e3,    "m/s",     "DAR source injection velocity")
`MPRoz(mu0rd,    100e-3,   "m^2/Vs",  "DAR low-field mobility")
`MPRoz(betard,   1.00,     "",        "DAR linear to saturation parameter")
`MPRcz(delta1rd, 0.35,     "",        "DAR DIBL Coefficient")
`MPRoz(srd,      0.3,      "V/dec",   "DAR Sub-threshold slope")
`MPRcz(ndrd,     3.8,      "",        "DAR punchthrough factor for subth slope")
`MPRcz(vthetard, 0.0,      "1/V",     "DAR scattering: velocity reduction parameter with Vg")
`MPRcz(mthetard, 0.0,      "1/V",     "DAR scattering: mobility reduction parameter with Vg")
`MPRoz(alphard,  3.5,      "",        "DAR weak to strong inversion transition factor, NOTE: alphard should scale up linearly with srd: alphrd=3.5 for srd=65mV/dec")

// Source-side Field-Plate 1 parameters
`MPIsw(flagfps1, 1,        "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfps1,   0.0,      "m",       "FP Length")
`MPRnb(vtofps1,  -44.5,    "V",       "FP threshold voltage")
`MPRoz(cgfps1,   2.0e-4,   "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfps1,  0.0,      "1/K",     "cgfps1 dependence on temperature")
`MPIsw(flagfps1s,1,        "",        "Flag parameter: cfps1s select=1 or cfp1s not select=0")
`MPRcz(cfps1s,   0e-19,    "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfps1b,1,        "",        "Flag parameter: ccfps1, cbfps1 select=1 or ccfps1, cbfps1 not select=0")
`MPRcz(ccfps1,   0.9e-10,  "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfps1,  0.0,      "1/K",     "ccfps1 dependence on temperature")
`MPRcz(cbfps1,   0.0,      "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfps1,  0.0,      "1/K",     "cbfps1 dependence on temperature")
`MPRoz(vx0fps1,  1.2e5,    "m/s",     "FP source injection velocity")
`MPRoz(mu0fps1,  0.2,      "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafps1, 1.00,     "",        "FP linear to saturation parameter")
`MPRcz(delta1fps1,0.0,     "",        "FP DIBL Coefficient")
`MPRoz(sfps1,    3.2,      "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfps1,   0.0,      "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafps1,-0.4e-3, "V/K",     "vto dependence on temperature")
`MPRcz(vthetafps1,0.0,     "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafps1,0.0,     "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafps1, 1e-2,    "",        "FP weak to strong inversion transition factor, NOTE: alphafps1 should scale up linearly with sfps1: alphafps1=3.5 for sfps1=65mV/dec")

// Source-side Field-Plate 2 parameters
`MPIsw(flagfps2,  0,       "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfps2,    0.0,     "m",       "FP Length")
`MPRnb(vtofps2,   -74.5,   "V",       "FP threshold voltage")
`MPRoz(cgfps2,    1.0e-4,  "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfps2,   0.0,     "1/K",     "cgfps2 dependence on temperature")
`MPIsw(flagfps2s, 1,       "",        "Flag parameter: cfsp2s select=1 or cfps2s not select=0")
`MPRcz(cfps2s,    0e-19,   "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfps2b, 1,        "",       "Flag parameter: ccfps2, cbfps2 select=1 or ccfps2, cbfps2 not select=0")
`MPRcz(ccfps2,    0.3e-10, "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfps2,   0.0,     "1/K",     "ccfps2 dependence on temperature")
`MPRcz(cbfps2,    0.0,     "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfps2,   0.0,     "1/K",     "cbfps2 dependence on temperature")
`MPRoz(vx0fps2,   1.2e5,   "m/s",     "FP source injection velocity")
`MPRoz(mu0fps2,   0.2,     "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafps2,  1.00,    "",        "FP linear to saturation parameter")
`MPRcz(delta1fps2,0.0,     "",        "FP DIBL Coefficient")
`MPRoz(sfps2,     3.2,     "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfps2,    0.0,     "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafps2,-0.4e-3, "V/K",     "vto dependence on temperature")
`MPRcz(vthetafps2,0.0,     "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafps2,0.0,     "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafps2, 1e-2,    "",        "FP weak to strong inversion transition factor, NOTE: alphafps2 should scale up linearly with sfps2: alphafps2=3.5 for sfps2=65mV/dec")

// Source-side Field-Plate 3 parameters
`MPIsw(flagfps3,  0,       "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfps3,    0.0,     "m",       "FP Length")
`MPRnb(vtofps3,   -74.5,   "V",       "FP threshold voltage")
`MPRoz(cgfps3,    1.0e-4,  "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfps3,   0.0,     "1/K",     "cgfps3 dependence on temperature")
`MPIsw(flagfps3s, 1,       "",        "Flag parameter: cfps3s select=1 or cfps3s not select=0")
`MPRcz(cfps3s,    0e-19,   "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfps3b, 1,        "",       "Flag parameter: ccfps3, cbfps3 select=1 or ccfps3, cbfps3 not select=0")
`MPRcz(ccfps3,    0.3e-10, "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfps3,   0.0,     "1/K",     "ccfps3 dependence on temperature")
`MPRcz(cbfps3,    0.0,     "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfps3,   0.0,     "1/K",     "cbfps3 dependence on temperature")
`MPRoz(vx0fps3,   1.2e5,   "m/s",     "FP source injection velocity")
`MPRoz(mu0fps3,   0.2,     "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafps3,  1.00,    "",        "FP linear to saturation parameter")
`MPRcz(delta1fps3,0.0,     "",        "FP DIBL Coefficient")
`MPRoz(sfps3,     3.2,     "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfps3,    0.0,     "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafps3,-0.4e-3, "V/K",     "vto dependence on temperature")
`MPRcz(vthetafps3,0.0,     "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafps3,0.0,     "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafps3, 1e-2,    "",        "FP weak to strong inversion transition factor, NOTE: alphafps3 should scale up linearly with sfps3: alphafps3=3.5 for sfps3=65mV/dec")

// Source-side Field-Plate 4 parameters
`MPIsw(flagfps4,  0,       "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfps4,    0.0,     "m",       "FP Length")
`MPRnb(vtofps4,   -74.5,   "V",       "FP threshold voltage")
`MPRoz(cgfps4,    1.0e-4,  "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfps4,   0.0,     "1/K",     "cgfps4 dependence on temperature")
`MPIsw(flagfps4s, 1,       "",        "Flag parameter: cfps4s select=1 or cfps4s not select=0")
`MPRcz(cfps4s,    0e-19,   "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfps4b, 1,        "",       "Flag parameter: ccfps4, cbfps4 select=1 or ccfps4, cbfps4 not select=0")
`MPRcz(ccfps4,    0.3e-10, "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfps4,   0.0,     "1/K",     "ccfps4 dependence on temperature")
`MPRcz(cbfps4,    0.0,     "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfps4,   0.0,     "1/K",     "cbfps4 dependence on temperature")
`MPRoz(vx0fps4,   1.2e5,   "m/s",     "FP source injection velocity")
`MPRoz(mu0fps4,   0.2,     "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafps4,  1.00,    "",        "FP linear to saturation parameter")
`MPRcz(delta1fps4,0.0,     "",        "FP DIBL Coefficient")
`MPRoz(sfps4,     3.2,     "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfps4,    0.0,     "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafps4,-0.4e-3, "V/K",     "vto dependence on temperature")
`MPRcz(vthetafps4,0.0,     "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafps4,0.0,     "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafps4, 1e-2,    "",        "FP weak to strong inversion transition factor, NOTE: alphafps4 should scale up linearly with sfps4: alphafps4=3.5 for sfps4=65mV/dec")

// Field-Plate 1 parameters
`MPIsw(flagfp1,  1,        "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfp1,    0.0,      "m",       "FP Length")
`MPRnb(vtofp1,   -44.5,    "V",       "FP threshold voltage")
`MPRoz(cgfp1,    2.0e-4,   "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfp1,   0.0,      "1/K",     "cgfp1 dependence on temperature")
`MPIsw(flagfp1s, 1,        "",        "Flag parameter: cfp1s select=1 or cfp1s not select=0")
`MPRcz(cfp1s,    0e-19,    "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfp1b, 1,        "",        "Flag parameter: ccfp1, cbfp1 select=1 or ccfp1, cbfp1 not select=0")
`MPRcz(ccfp1,    0.9e-10,  "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfp1,   0.0,      "1/K",     "ccfp1 dependence on temperature")
`MPRcz(cbfp1,    0.0,      "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfp1,   0.0,      "1/K",     "cbfp1 dependence on temperature")
`MPRoz(vx0fp1,   1.2e5,    "m/s",     "FP source injection velocity")
`MPRoz(mu0fp1,   0.2,      "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafp1,  1.00,     "",        "FP linear to saturation parameter")
`MPRcz(delta1fp1,0.0,      "",        "FP DIBL Coefficient")
`MPRoz(sfp1,     3.2,      "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfp1,    0.0,      "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafp1,-0.4e-3,  "V/K",     "vto dependence on temperature")
`MPRcz(vthetafp1,0.0,      "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafp1,0.0,      "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafp1, 1e-2,     "",        "FP weak to strong inversion transition factor, NOTE: alphafp1 should scale up linearly with sfp1: alphafp1=3.5 for sfp1=65mV/dec")

// Field-Plate 2 parameters
`MPIsw(flagfp2,  0,        "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfp2,    0.0,      "m",       "FP Length")
`MPRnb(vtofp2,   -74.5,    "V",       "FP threshold voltage")
`MPRoz(cgfp2,    1.0e-4,   "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfp2,   0.0,      "1/K",     "cgfp2 dependence on temperature")
`MPIsw(flagfp2s, 1,        "",        "Flag parameter: cfp2s select=1 or cfp2s not select=0")
`MPRcz(cfp2s,    0e-19,    "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfp2b, 1,        "",        "Flag parameter: ccfp2, cbfp2 select=1 or ccfp2, cbfp2 not select=0")
`MPRcz(ccfp2,    0.3e-10,  "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfp2,   0.0,      "1/K",     "ccfp2 dependence on temperature")
`MPRcz(cbfp2,    0.0,      "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfp2,   0.0,      "1/K",     "cbfp2 dependence on temperature")
`MPRoz(vx0fp2,   1.2e5,    "m/s",     "FP source injection velocity")
`MPRoz(mu0fp2,   0.2,      "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafp2,  1.00,     "",        "FP linear to saturation parameter")
`MPRcz(delta1fp2,0.0,      "",        "FP DIBL Coefficient")
`MPRoz(sfp2,     3.2,      "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfp2,    0.0,      "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafp2,-0.4e-3,  "V/K",     "vto dependence on temperature")
`MPRcz(vthetafp2,0.0,      "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafp2,0.0,      "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafp2, 1e-2,     "",        "FP weak to strong inversion transition factor, NOTE: alphafp2 should scale up linearly with sfp2: alphafp2=3.5 for sfp2=65mV/dec")

// Field-Plate 3 parameters
`MPIsw(flagfp3,  0,        "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfp3,    0.0,      "m",       "FP Length")
`MPRnb(vtofp3,   -74.5,    "V",       "FP threshold voltage")
`MPRoz(cgfp3,    2.0e-4,   "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfp3,   0.0,      "1/K",     "cgfp3 dependence on temperature")
`MPIsw(flagfp3s, 1,        "",        "Flag parameter: cfp3s select=1 or cfp3s not select=0")
`MPRcz(cfp3s,    0e-19,    "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfp3b, 1,        "",        "Flag parameter: ccfp3, cbfp3 select=1 or ccfp3, cbfp3 not select=0")
`MPRcz(ccfp3,    0.9e-10,  "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfp3,   0.0,      "1/K",     "ccfp3 dependence on temperature")
`MPRcz(cbfp3,    0.0,      "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfp3,   0.0,      "1/K",     "cbfp3 dependence on temperature")
`MPRoz(vx0fp3,   1.2e5,    "m/s",     "FP source injection velocity")
`MPRoz(mu0fp3,   0.2,      "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafp3,  1.00,     "",        "FP linear to saturation parameter")
`MPRcz(delta1fp3,0.0,      "",        "FP DIBL Coefficient")
`MPRoz(sfp3,     3.2,      "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfp3,    0.0,      "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafp3,-0.4e-3,  "V/K",     "vto dependence on temperature")
`MPRcz(vthetafp3,0.0,      "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafp3,0.0,      "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafp3, 1e-2,     "",        "FP weak to strong inversion transition factor, NOTE: alphafp3 should scale up linearly with sfp3: alphafp3=3.5 for sfp3=65mV/dec")

// Field-Plate 4 parameters
`MPIsw(flagfp4,  0,        "",        "Flag parameter: GFP=1 or SFP=0")
`MPRcz(lgfp4,    0.0,      "m",       "FP Length")
`MPRnb(vtofp4,   -74.5,    "V",       "FP threshold voltage")
`MPRoz(cgfp4,    2.0e-4,   "F/m^2",   "FP gate-cap/area")
`MPRnb(tcgfp4,   0.0,      "1/K",     "cgfp4 dependence on temperature")
`MPIsw(flagfp4s, 1,        "",        "Flag parameter: cfp4s select=1 or cfp4s not select=0")
`MPRcz(cfp4s,    0e-19,    "F/m",     "FP (source-side) to source cap/width")
`MPIsw(flagfp4b, 1,        "",        "Flag parameter: ccfp4, cbfp4 select=1 or ccfp4, cbfp4 not select=0")
`MPRcz(ccfp4,    0.9e-10,  "F/m",     "Source or gate to drain (under FP) cap/width")
`MPRnb(tccfp4,   0.0,      "1/K",     "ccfp4 dependence on temperature")
`MPRcz(cbfp4,    0.0,      "F/m",     "Body to drain (under FP) cap/width")
`MPRnb(tcbfp4,   0.0,      "1/K",     "cbfp4 dependence on temperature")
`MPRoz(vx0fp4,   1.2e5,    "m/s",     "FP source injection velocity")
`MPRoz(mu0fp4,   0.2,      "m^2/Vs",  "FP low-field mobility")
`MPRoz(betafp4,  1.00,     "",        "FP linear to saturation parameter")
`MPRcz(delta1fp4,0.0,      "",        "FP DIBL Coefficient")
`MPRoz(sfp4,     3.2,      "V/dec",   "FP Sub-threshold slope")
`MPRcz(ndfp4,    0.0,      "",        "FP punchthrough factor for subth slope")
`MPRnb(vtzetafp4,-0.4e-3,  "V/K",     "vto dependence on temperature")
`MPRcz(vthetafp4,0.0,      "1/V",     "FP scattering: velocity reduction parameter with Vg")
`MPRcz(mthetafp4,0.0,      "1/V",     "FP scattering: mobility reduction parameter with Vg")
`MPRoz(alphafp4, 1e-2,     "",        "FP weak to strong inversion transition factor, NOTE: alphafp4 should scale up linearly with sfp4: alphafp4=3.5 for sfp4=65mV/dec")

// Gate leakage parameters
`MPIsw(igmod,    0,        "",        "Flag parameter for gate leakage 0=off, 1=on")
`MPRcz(fracig,   0,        "",        "Fraction of IG flowing through FP- and access-Tx")
`MPRcz(vjg,      1.1,      "V",       "Gate diode cut in voltage")
`MPRcz(pg_param1,820e-3,   "1/V",     "Temperature coefficient of exponent")

`MPRcz(pg_params,1.00,     "1/V",     "G-S diode  inverse of ideality factor")
`MPRcz(ijs,      1.00e-12, "A/m",     "G-S reverse leakage current normalized to width")
`MPRcz(vgsats,   1.00,     "V",       "G-S high injection effect")
`MPRcc(fracs,    0.5,      "", 0, 1,  "G-S fractional change in ideality factor due to high injection")
`MPRoz(alphags,  1.0,      "",        "G-S high injection smoothing parameter")
`MPRcz(pg_paramd,1.00,     "1/V",     "G-D diode  inverse of ideality factor")
`MPRcz(ijd,      1.00e-12, "A/m",     "G-D reverse leakage current normalized to width")
`MPRcz(vgsatd,   1.00,     "V",       "G-D high injection effect")
`MPRcc(fracd,    0.5,      "", 0, 1,  "G-D fractional change in ideality factor due to high injection")
`MPRoz(alphagd,  1.0,      "",        "G-D high injection smoothing parameter")

`MPRcz(pgsrecs,  0.5,      "",        "G-S diode  inverse of ideality factor reverse recombination")
`MPRcz(irecs,    1.0e-18,  "A/m",     "G-S reverse leakage current normalized to width")
`MPRoz(vgsatqs,  2.00,     "V",       "G-S mimics depletion saturation")
`MPRoz(betarecs, 2.00,     "",        "G-S linear to saturation parameter")
`MPRcz(pgsrecd,  0.8,      "",        "G-D diode  inverse of ideality factor for reverse recombination")
`MPRcz(irecd,    2e-5,     "A/m",     "G-D reverse leakage current normalized to width")
`MPRoz(vgsatqd,  0.8,      "V",       "G-D mimics depletion saturation")
`MPRoz(betarecd, 0.25,     "",        "G-D linear to saturation parameter")

`MPRcz(kbdgates, 00,       "",        "G-S fitting parameter to turn on the breakdown of G-S diode")
`MPRcz(vbdgs,    600,      "V",       "G-S soft breakdown voltage of G-S diode")
`MPRcz(pbdgs,    4.00,     "1/V",     "G-S fitting parameter for breakdown: inverse of ideality factor")
`MPRcz(kbdgated, 00,       "",        "G-D fitting parameter to turn on the breakdown of G-D diode")
`MPRcz(vbdgd,    600,      "V",       "G-D soft breakdown voltage of G-D diode")
`MPRcz(pbdgd,    4.00,     "1/V",     "G-D fitting parameter for breakdown: inverse of ideality factor")

`MPIsw(igrecmod, 0,        "",        "Flag parameter to turn on secondary gate-recombination current 0=off, 1=on")
`MPRcz(pgsrecs2, 0.5,      "",        "Secondary G-S diode  inverse of ideality factor reverse recombination")
`MPRcz(irecs2,   1.0e-18,  "A/m",     "Secondary G-S reverse leakage current normalized to width")
`MPRoz(vgsatqs2, 2.00,     "V",       "Secondary G-S mimics depletion saturation")
`MPRoz(betarecs2,2.00,     "",        "Secondary G-S linear to saturation parameter")
`MPRcz(pgsrecd2, 0.8,      "",        "Secondary G-D diode  inverse of ideality factor for reverse recombination")
`MPRcz(irecd2,   2e-5,     "A/m",     "Secondary G-D reverse leakage current normalized to width")
`MPRoz(vgsatqd2, 0.8,      "V",       "Secondary G-D mimics depletion saturation")
`MPRoz(betarecd2,0.25,     "",        "Secondary G-D linear to saturation parameter")


//p-Gan junction parameters
`MPIsw(flagpgan,     0,    "",        "Flag parameter for pGan calculations 0=off, 1=on")

`MPRcz(pg_param_pgan,0.05, "1/V",     "pGan forward diode inverse of ideality factor")
`MPRcz(ij_pgan,      2e-5, "A/m",     "pGan forward diode leakage current normalized to width")
`MPRcz(vgsat_pgan,   3,    "V",       "pGan high injection effect")
`MPRcc(frac_pgan,    0.4,  "", 0, 1,  "pGan fractional change in ideality factor due to high injection")
`MPRoz(alphag_pgan,  1.0,  "",        "pGan high injection smoothing parameter")

`MPRcz(pgsrec_pgan,  0.5,  "",        "pGan diode inverse of ideality factor reverse recombination")
`MPRcz(irec_pgan,    1e-21,"A/m",     "pGan reverse leakage current normalized to width")
`MPRoz(vgsatq_pgan,  2e4,  "V",       "pGan mimics depletion saturation")
`MPRoz(betarec_pgan, 1,     "",       "pGan linear to saturation parameter")

`MPIsw(pganrecmod,   0,    "",        "Flag parameter to turn on secondary gate-recombination current for p-Gan 0=off, 1=on")
`MPRcz(pgsrec_pgan2, 0.5,  "",        "Secondary pGan diode inverse of ideality factor reverse recombination")
`MPRcz(irec_pgan2,   1e-21,"A/m",     "Secondary pGan reverse leakage current normalized to width")
`MPRoz(vgsatq_pgan2, 2e4,  "V",       "Secondary pGan mimics depletion saturation")
`MPRoz(betarec_pgan2,1,    "",        "Secondary pGan linear to saturation parameter")

`MPRoz(vcsh0,        2.0,  "V",       "Built in potential of pGan Schottky junction")
`MPRcz(csh0,         6e-8, "F/m",     "pGan zero bias Schottky junction capacitance")
`MPRco(fc,           0.5,  "",  0, 1, "Fractional change in pGan charge between 0 and root domain boundary before Taylor series")
`MPIcc(pgancshorder, 2,    "",  0, 5, "Order of Taylor series to compute pGan charge beyond fc*vcsh0")
`MPRcz(rsch0,        0,    "Ohm*m",   "Ohmic contact for the Schottky junction normalized to width")
`MPRcc(ohmicratio,   0,    "m", 0, 1, "Fraction of device width that is ohmic, wsch = w * ohmicratio")


// Channel breakdown model
`MPIsw(icbdmod,  0,        "",        "Flag parameter for channel breakdown 0=off, 1=on")
`MPIsw(cbddbmod, 1,        "",        "Flag parameter for channel breakdown debiasing 0=off, 1=on")
`MPRcz(ijscbd,   1.00e-9,  "A/m",     "G-S reverse channel breakdown leakage current normalized to width")
`MPRcz(ijdcbd,   1.00e-9,  "A/m",     "G-S reverse channel breakdown leakage current normalized to width")
`MPRcz(vchbdgs,  50,       "V",       "G-S soft breakdown voltage of channel diode")
`MPRcz(pchbdgs,  4.00,     "1/V",     "G-S fitting parameter for channel breakdown: inverse of ideality factor")
`MPRcz(vchbdgd,  50,       "V",       "G-D soft breakdown voltage of channel diode")
`MPRcz(pchbdgd,  4.00,     "1/V",     "G-D fitting parameter for channel breakdown: inverse of ideality factor")

// Thermal sub-circuit parameters
`MPRcz(rth,      25,       "K/W ",    "Thermal resistance")
`MPRcz(cth,      1e-4,     "s*W/K",   "Thermal capacitance")

// RF gm-dispersion parameters
`MPIsw(gmdisp,   0,        "",        "Flag parameter for gm-dispersion 0=off, 1=on")
`MPRcz(taugmrf,  1e-3,     "s",       "gm-dispersion time constant")

// Layout and DC-to-RF gate-resistance parameters
`MPRcz(rgsp,     0.0,      "Ohms/m",  "Gate resistance / Width for 1 finger and 1 gate-contact")
`MPRoz(ngcon,    1,        "",        "Number of gate-contacts per finger")
`MPRcz(lovg,     0,        "m",       "Length of gate-finger line between gate-contact and the beginning of active gate-width")
`MPRcz(agate,    1,        " ",       "DC-to-RF dispersion factor; fraction=1 DC value maintained at all frequencies")

// Trapping model parameters for Ron and Isat increase
`MPIcc(trapselect,0,       "",  0, 2, "Select knob for charge trapping 0=off, 1=Rdson trapping on, 2=Isat and Rdson trapping on")
`MPRoz(rintrap1, 1e9,      "Ohm",     "Input trapping shunt resistance")
`MPRcz(ctrap,    1e-3,     "F",       "DC-block capacitor")
`MPRcz(vttrap,   100,      "V",       "Trapping stress threshold voltage")
`MPRcz(taut,     3e-5,     "s",       "Trap time constant")
`MPRcz(alphat1,  1e-3,     "",        "Trap coefficient 1 on bias stress")
`MPRoz(alphat2,  0.05,     "V",       "Trap coefficient 2 on bias stress")
`MPRoz(alphat3,  1e-3,     "",        "Input trapping feedback factor")
`MPRcz(tempt,    1e-4,     "1/K",     "Temperature coefficient for trapping")
`MPRoz(vgltrapth,10,       "V",       "Trapping Drain-lag stress threshold voltage")
`MPRoz(vdltrapth,100,      "V",       "Trapping Gate-lag stress threshold voltage")
`MPRoz(rcapture, 10.0,     "Ohm",     "Trapping capture time constant associated with capture of electron (a slower process)")
`MPRoz(remission,50e-3,    "Ohm",     "Trapping emission time constant associated with emission of electron (a faster process)")
`MPRoz(cdglag,   1e-6,     "F",       "Trapping emission and capture time constant-C")
`MPRnb(rct1dl,   -5e-3,    "1/K",     "Linear Drain-lag temperature coefficient")
`MPRnb(rct1gl,   5e-3,     "1/K",     "Linear Gate-lag temperature coefficient")
`MPRnb(rct2dl,   0.0,      "1/K^2",   "Quadratic Drain-lag temperature coefficient")
`MPRnb(rct2gl,   0.0,      "1/K^2",   "Quadratic Gate-lag temperature coefficient")
`MPRcz(isat,     1.0e-9,   "A",       "Trapping reverse saturation current for diode")

// Noise model parameters
`MPIsw(noisemod, 0,       "",         "Select knob for noise model 0=off, 1=on")
`MPRcz(shs,      3.0,     "",         "G-S shot noise parameter")
`MPRcz(shd,      3.0,     "",         "G-D shot noise parameter")
`MPRcz(kf,       1.0e-4,  "",         "Flicker noise coefficient")
`MPRcz(af,       2.0,     "",         "Flicker noise exponent")
`MPRoz(ffe,      1.2,     "",         "Flicker noise exponent for frequency")

// Minimum element parameters
`MPRcz(minr,     $simparam("minr",1m),"Ohm", "Minimum resistance")
`MPRcz(minl,     1.0e-9,  "m",        "Minimum length of access or FP regions for modeling them as transistors")
`MPRcz(minc,     0.0,     "F",        "Minimum capacitance")

analog function real absfunc;
    input x, s;
    real x, s;
    begin
        if (flaggum==0) begin
            absfunc=sqrt( x * x + s );
        end else begin
            absfunc= x * tanh( ( 1.0e-3 / s ) * x );
        end
    end
endfunction

analog function real mmax;
    input x,y,s;
    real x,y,s;
    begin
        if (flaggum==0) begin
            mmax=0.5 * ( x + y + sqrt( ( x - y ) * ( x - y ) + s ) );
        end else begin
            mmax=0.5 * ( x + y + ( x - y ) * tanh( ( 1.0e-3 / s ) * ( x - y ) ) );
        end
    end
endfunction

analog function real explim;
    input x;
    real x;
    begin
        if (x>`M_MAXEXP) begin
            explim = exp( `M_MAXEXP ) * ( 1.0 + ( x - `M_MAXEXP ));
        end else if (x<-`M_MAXEXP) begin
            explim = exp( -`M_MAXEXP );
        end else begin
            explim = exp( x );
        end
    end
endfunction

analog function real calc_iq;
    output idsout,qgsout,qgdout,qcout,qbout,qsout,vtdibl,vdsat1;
    input vgsin,vdsin,qcbflag,vcin,vbin,qgsflag,tambin,tnomin,phitin,w,lin,cgin,cs,cc,cb,vto,ss;
    input delta1,delta2,nd,alpha,vel0,mu0,beta,mtheta,vtheta;
    input vtzeta,dibsat,epsilon,vzeta,lambda,ngf,type, trapfracdl;

    // IO
    real  idsout,qgsout,qgdout,qcout,qbout,qsout,vtdibl,vdsat1,vgsin,vdsin,qcbflag,vcin,vbin,qgsflag;
    real  tambin,tnomin,phitin,w,lin,cgin,cs,cc,cb,vto,ss,delta1,delta2,nd,alpha,vel0,mu0,beta,mtheta,vtheta;
    real  vtzeta,dibsat,epsilon,vzeta,lambda,ngf,type, trapfracdl;

    // Local
    real  alpha_phit, delta, n, vtof, vsatdibl, ffs, two_n_phit, qref, etas, qinvs, muf, vx, vxf;
    real  n0, ffs0, two_n_phit0, qref0, etas0, qinvs0, muf0, vx0, tfacmobin;
    real  ff, eta, qinvv;
    real  ff0, eta0, qinvv0;
    real  vdsats, vdsats1, vdsat, fsd, vdx, fds, vsx, ffd, etad, qinvd, vdsc, fsat, vel;
    real  vdsats0, vdsats10, vdsat10, fsd0, vdx0, fds0, vsx0, ffd0, etad0, qinvd0;
    real  qs2, qs3, qd2, qd3, qsqd, qinvdd, qd1, qs, qd, etac, etab, etags;
    real  exparg, myarg, absvdsin, vgdin;
    real  exparg0, myarg0;

    begin
        absvdsin     = absfunc( vdsin, mmaxs );
        vgdin        = vgsin - vdsin;
        alpha_phit   = alpha * phitin;
        n            = ss / ( `M_LN10 * phitin ) + nd * absvdsin;
        vtof         = vto + vtzeta * ( tambin - tnomin );
        tfacmobin    = pow(( tambin / tnomin ), epsilon );
        if (dibsat != 0) begin
            vsatdibl  = absvdsin / ( pow(( 1.0 + pow( absvdsin / dibsat, beta)),( 1.0/beta )));
        end else begin
            vsatdibl  = 0;
        end
        delta        = ( delta1 - vsatdibl * delta2 ) * absvdsin;
        vtdibl       = vtof - delta;
        two_n_phit   = 2.0 * n * phitin;
        qref         = cgin * two_n_phit;
        // Qinvv
        myarg        = vtdibl - flagsp * alpha_phit / 2.0;
        exparg       = (( mmax( vgsin,vgdin,mmaxs ) - myarg ) / ( alpha_phit ));
        if (exparg > `M_MAXEXP) begin
            ff        = 0.0;
        end else if (exparg < -`M_MAXEXP) begin
            ff        = 1.0;
        end else begin
            ff        = 1.0 / ( 1.0 + exp( exparg ));
        end
        eta          = ( mmax( vgsin,vgdin,mmaxs ) - ( vtdibl - flagsp * 0.1 * alpha_phit * ff )) / two_n_phit;
        if (eta > `M_MAXEXP) begin
            qinvv     = qref * eta;
        end else if (eta < -`M_MAXEXP) begin
            qinvv     = qref * exp( eta );
        end else begin
            qinvv     = qref * ln( 1.0 + exp( eta ));
        end
        // velocity
        muf          = mu0 / ( tfacmobin * ( 1.0 + mtheta * qinvv /cgin ));
        vx           = vel0 * (( 1.0 + vzeta * tnomin ) / ( 1.0 + vzeta * tambin )) * ( 1.0 + lambda * absvdsin /lin) / ( 1.0 + vtheta * qinvv/ cgin );
        vxf          = 2.0 * ff * phitin * muf / lin + ( 1.0 - ff ) * vx;
        vdsats       = vx * lin / muf;
        vdsats1      = vdsats * sqrt( 1.0 + 2.0 * qinvv / cgin / vdsats ) - vdsats;
        vdsat        = vdsats * ( 1.0 - ff ) + two_n_phit * ff;
        vdsat1       = vdsats1 * ( 1.0 - ff ) + two_n_phit * ff;
        fsd          = 1.0 / pow( 1.0 + pow( mmax( 0,( vdsin / vdsat1 ),mmaxs),beta ),1.0 / beta);
        vdx          = vdsin * fsd;
        fds          = 1.0 / pow( 1.0 + pow( mmax( 0,( -vdsin / vdsat1 ),mmaxs),beta),1.0 / beta);
        vsx          = -vdsin * fds;
        // Qinvs
        exparg       = ( vgsin - myarg ) / ( alpha_phit );
        if (exparg > `M_MAXEXP) begin
            ffs       = 0.0;
        end else if (exparg < -`M_MAXEXP) begin
            ffs       = 1.0;
        end else begin
            ffs       = 1.0  /( 1.0 +  exp( exparg ));
        end
        etas         = ( vgdin - vsx - ( vtdibl - flagsp * 0.1 * alpha_phit * ffs )) / two_n_phit;
        if (etas > `M_MAXEXP) begin
            qinvs     = qref * etas;
        end else if (etas < -`M_MAXEXP) begin
            qinvs     = qref * exp( etas );
        end else begin
            qinvs     = qref * ln( 1.0 + exp( etas ));
        end
        // Qinvd
        exparg       = ( vgdin - myarg ) / ( alpha_phit );
        if (exparg > `M_MAXEXP) begin
            ffd       = 0.0;
        end else if (exparg < -`M_MAXEXP) begin
            ffd       = 1.0;
        end else begin
            ffd       = 1.0 / ( 1.0 + exp( exparg ));
        end
        etad         = ( vgsin - vdx - ( vtdibl - flagsp * 0.1 * alpha_phit * ffd )) / two_n_phit;
        if (etad > `M_MAXEXP) begin
            qinvd     = qref * etad;
        end else if (etad < -`M_MAXEXP) begin
            qinvd     = qref * exp( etad );
        end else begin
            qinvd     = qref * ln( 1.0 + exp( etad ));
        end
        // Current
        vdsc         = ( qinvs - qinvd ) / cgin;
        myarg        = vdsc / vdsat;
        fsat         = myarg / ( pow( 1.0 + pow( absfunc( myarg, mmaxs ),beta), 1.0 / beta));
        vel          = vxf * fsat;
        idsout       = type * w * ngf * 0.5 * ( qinvs + qinvd ) * vel * trapfracdl;

        // charge calc
        n0           = ss / ( `M_LN10 * phitin );
        two_n_phit0  = 2.0 * n0 * phitin;
        qref0        = cgin * two_n_phit0;
        // Qinvv0
        myarg0       = vtof - flagsp * alpha_phit / 2.0;
        exparg0      = (( mmax( vgsin,vgdin,mmaxs ) - myarg0 )/( alpha_phit ));
        if (exparg0 > `M_MAXEXP) begin
            ff0       = 0.0;
        end else if (exparg0 < -`M_MAXEXP) begin
            ff0       = 1.0;
        end else begin
            ff0       = 1.0 / ( 1.0 + exp( exparg0 ));
        end
        eta0         = ( mmax( vgsin,vgdin,mmaxs ) - ( vtof - flagsp * 0.1 * alpha_phit * ff0 )) / two_n_phit0;
        if (eta0 > `M_MAXEXP) begin
            qinvv0    = qref0 * eta0;
        end else if (eta0 < -`M_MAXEXP) begin
            qinvv0    = qref0 * exp( eta0 );
        end else begin
            qinvv0    = qref0 * ln( 1.0 + exp( eta0 ));
        end
        // velocity0
        muf0         = mu0 / tfacmobin;
        vx0          = vel0 * (( 1.0 + vzeta * tnomin ) / ( 1.0 + vzeta * tambin ));
        vdsats0      = vx0 * lin / muf0;
        vdsats10     = vdsats0 * sqrt( 1.0 + 2.0 * qinvv0 / cgin / vdsats0 ) - vdsats0;
        vdsat10      = vdsats10 * ( 1.0 - ff0 ) + two_n_phit0 * ff0;
        fsd0         = 1.0 / pow( 1.0 + pow( mmax(0,( vdsin / vdsat10 ),mmaxs),beta ),1.0 / beta);
        vdx0         = vdsin * fsd0;
        fds0         = 1.0 / pow( 1.0 + pow( mmax(0,( -vdsin / vdsat10 ),mmaxs),beta ),1.0 / beta);
        vsx0         = -vdsin * fds0;
        exparg0      = ( vgsin - myarg0 ) / ( alpha_phit );
        if (exparg0 > `M_MAXEXP) begin
            ffs0      = 0.0;
        end else if (exparg0 < -`M_MAXEXP) begin
            ffs0      = 1.0;
        end else begin
            ffs0      = 1.0 / ( 1.0 + exp( exparg0 ));
        end
        etas0        = ( vgdin - vsx0 - ( vtof - flagsp * 0.1 * alpha_phit * ffs0 )) / two_n_phit0;
        if (etas0 > `M_MAXEXP) begin
            qinvs0    = qref0 * etas0;
        end else if (etas0 < -`M_MAXEXP) begin
            qinvs0    = qref0 * exp( etas0 );
        end else begin
            qinvs0    = qref0 * ln( 1.0 + exp( etas0 ));
        end
        exparg0      = ( vgdin - myarg0 ) / ( alpha_phit );
        if (exparg0 > `M_MAXEXP) begin
            ffd0      = 0.0;
        end else if (exparg0 < -`M_MAXEXP) begin
            ffd0      = 1.0;
        end else begin
            ffd0      = 1.0 / ( 1.0 + exp( exparg0 ));
        end
        etad0        = ( vgsin - vdx0 - ( vtof - flagsp * 0.1 * alpha_phit * ffd0 )) / two_n_phit0;
        if (etad0 > `M_MAXEXP) begin
            qinvd0    = qref0 * etad0;
        end else if (etad0 < -`M_MAXEXP) begin
            qinvd0    = qref0 * exp( etad0 );
        end else begin
            qinvd0    = qref0 * ln( 1.0 + exp( etad0 ));
        end
        qs2          = qinvs0 * qinvs0 + 1e-38;
        qs3          = qs2 * qinvs0 + 1e-57;
        qd2          = qinvd0 * qinvd0 + 1e-38;
        qd3          = qd2 * qinvd0 + 1e-57;
        qsqd         = qinvs0 * qinvd0 + 1e-38;
        qinvdd       = 2.0 / 3.0 * ( qs2 + qd2 + qsqd ) / ( qinvs0 + qinvd0 + 2e-19 );
        qd1          = 2.0 * ( 2.0 * qs3 + 3.0 * qd3 + 4.0 * qs2 * qinvd0 + 6.0 * qd2 * qinvs0 ) / ( 15.0 * ( qs2+ qd2 + 2.0 * qsqd ));
        qs           = qinvdd - qd1;
        qd           = qd1;
        qgsout       = w * ngf * lin * type * qs * trapfracdl;
        qgdout       = w * ngf * lin * type * qd * trapfracdl;
        if (qcbflag==1) begin
            etac      = ( vcin - ( vtof - flagsp * 0.5 * alpha_phit )) / two_n_phit0;
            if (etac > `M_MAXEXP) begin
                exparg = etac;
            end else if (etac < -`M_MAXEXP) begin
                exparg = exp( etac );
            end else begin
                exparg = ln( 1.0 + exp( etac ));
            end
            qcout     = w * ngf * type * cc * two_n_phit0 * exparg * trapfracdl;
            etab      = ( vbin - ( vtof - flagsp * 0.5 * alpha_phit )) / two_n_phit0;
            if (etab > `M_MAXEXP) begin
                exparg = etab;
            end else if (etab < -`M_MAXEXP) begin
                exparg = exp( etab );
            end else begin
                exparg = ln( 1.0 + exp( etab ));
            end
            qbout     = w * ngf * type * cb * two_n_phit0 * exparg * trapfracdl;
        end else begin
            qcout     = 0;
            qbout     = 0;
        end
        if (qgsflag==1) begin
            etags     = ( vgsin - ( vtof - flagsp * 0.5 * alpha_phit )) / two_n_phit0;
            if (etags > `M_MAXEXP) begin
                exparg = etags;
            end else if (etags < -`M_MAXEXP) begin
                exparg = exp( etags  );
            end else begin
                exparg = ln( 1.0 + exp( etags  ));
            end
            qsout     = w * ngf * type * cs * two_n_phit0 * exparg * trapfracdl;
        end else begin
            qsout     = 0;
        end
        calc_iq      = idsout;
    end
endfunction

analog function real calc_ig;
    output isdiodeout, isrecout;
    input vgin, phitin;
    input vgsatin, alphagin, fracin, pg_paramin, pbdgin, vbdgin, tfacdiodein;
    input w, ngf,ijin, kbdgatein, vgsatqin, betarecin, irecin, pgsrecin, pg_param1, vjg, type;
    // IO
    real isdiodeout, isrecout;
    real vgin, phitin;
    real vgsatin, alphagin, fracin, pg_paramin, pbdgin, vbdgin, tfacdiodein;
    real w, ngf,ijin, kbdgatein, vgsatqin, betarecin, irecin, pgsrecin, pg_param1, vjg, type;
    // Local
    real igout, alpha2_phit, t0, ffvgin, iginbd, igindiode;
    real frecgin, iginrec;
    real expbdarg1, expbdarg2, expbd1, expbd2, expphib, expffvarg, expiforarg, expifor, expirevarg, expirev;
    real pg_paramin_hinj, expbdarg1_vgsat, expbd1_vgsat, iginbd_vgsat;
    real expiforarg_nohinj_vgsat, expifor_nohinj_vgsat, igindiode_nohinj_vgsat, igindiode_nohinj;
    real expiforarg_hinj_vgsat, expifor_hinj_vgsat, igindiode_hinj_vgsat;
    real expiforarg_hinj, expifor_hinj, igindiode_hinj_pre, igindiode_hinj;

    begin
        expphib      = pg_param1 / phitin * (- vjg);
        t0           = explim( expphib );

        expbdarg1    = pbdgin * ( -vgin  - vbdgin ) + expphib;
        expbdarg2    = -pbdgin * vbdgin + expphib;
        expbd1       = explim( expbdarg1 );
        expbd2       = explim( expbdarg2 );
        iginbd       = ( expbd1 - expbd2 );

        isdiodeout   = type * w * ngf * ijin * tfacdiodein;
        expiforarg   = pg_paramin / phitin * vgin + expphib;
        expifor      = explim( expiforarg );
        if (fracin == 1) begin
            igindiode    = isdiodeout * ( expifor - ( kbdgatein * iginbd ) - t0 );
        end else begin
            expbdarg1_vgsat = pbdgin * ( -vgsatin  - vbdgin ) + expphib;
            expbd1_vgsat    = explim( expbdarg1_vgsat );
            iginbd_vgsat    = ( expbd1_vgsat - expbd2 );

            expiforarg_nohinj_vgsat = pg_paramin / phitin * vgsatin + expphib;
            expifor_nohinj_vgsat    = explim( expiforarg_nohinj_vgsat );
            igindiode_nohinj_vgsat  = ( expifor_nohinj_vgsat - ( kbdgatein * iginbd_vgsat ) - t0 );

            igindiode_nohinj   = isdiodeout * ( expifor - ( kbdgatein * iginbd ) - t0 );
            if (fracin > 0) begin
                pg_paramin_hinj = fracin * pg_paramin;

                expiforarg_hinj_vgsat   = pg_paramin_hinj / phitin * vgsatin + expphib;
                expifor_hinj_vgsat      = explim( expiforarg_hinj_vgsat );
                igindiode_hinj_vgsat    = ( expifor_hinj_vgsat - ( kbdgatein * iginbd_vgsat ) - t0 );

                expiforarg_hinj    = pg_paramin_hinj / phitin * vgin + expphib;
                expifor_hinj       = explim( expiforarg_hinj );
                igindiode_hinj_pre = isdiodeout * igindiode_nohinj_vgsat / igindiode_hinj_vgsat;
                igindiode_hinj     = igindiode_hinj_pre * ( expifor_hinj - ( kbdgatein * iginbd ) - t0 );
            end else begin
                igindiode_hinj = isdiodeout * igindiode_nohinj_vgsat;
            end
            alpha2_phit  = alphagin * alphagin * phitin;
            expffvarg    = ( vgin - ( vgsatin - alpha2_phit / 2.0))/ alpha2_phit;
            if (expffvarg > `M_MAXEXP) begin
                ffvgin    = 0.0;
            end else if (expffvarg < -`M_MAXEXP) begin
                ffvgin    = 1.0;
            end else begin
                ffvgin    = 1.0 / ( 1.0 + exp( expffvarg ));
            end
            igindiode = ffvgin * igindiode_nohinj + ( 1.0 - ffvgin ) * igindiode_hinj;
        end

        frecgin      = -vgin / pow(( 1.0 + pow( absfunc( vgin  / vgsatqin, mmaxs ), betarecin )), 1.0 / betarecin );
        isrecout     = -type * w * ngf * irecin * tfacdiodein * 1.0;
        expirevarg   = pgsrecin / phitin * frecgin;
        expirev      = explim( expirevarg );
        iginrec      = isrecout * ( expirev - 1.0 );

        igout        = igindiode + iginrec;
        calc_ig      = igout;
    end
endfunction

analog function real calc_capt;
    input capin, tempcoin, tdutin, tnomkin;
    // IO
    real capin, tempcoin, tdutin, tnomkin;
    // Local
    real tcapfac;

    begin
        tcapfac      = 1.0 + tempcoin * ( tdutin - tnomkin );
        if (tcapfac  < 0.01) begin
            tcapfac   = 0.01;
        end
        calc_capt       = capin * tcapfac;
    end
endfunction

// Local variables
real gmin;
real rdi, rsi, rcs_w, rcd_w, rg1, rg2;
real cofsmt, cofdmt, cofdsmt, cofssubmt, cofdsubmt, cofgsubmt;
real cofsmt0, cofdmt0, cofdsmt0, cofssubmt0, cofdsubmt0, cofgsubmt0;
real cgt, cgfps1t, ccfps1t, cbfps1t, cgfps2t, ccfps2t, cbfps2t, cgfps3t, ccfps3t, cbfps3t, cgfps4t, ccfps4t, cbfps4t;
real cgfp1t, ccfp1t, cbfp1t, cgfp2t, ccfp2t, cbfp2t, cgfp3t, ccfp3t, cbfp3t, cgfp4t, ccfp4t, cbfp4t;
real vdsi, vgsi, vigs, vigd, vsars, vdars, vtdibli, vdsat1i, vgsrs, vdsrs, vtdiblrs, vdsatrs, vgsrd, vdsrd, vtdiblrd, vdsatrd;
real vgsfps1, vdsfps1, vcfps1, vbfps1, vtdiblfps1, vdsatfps1;
real vgsfps2, vdsfps2, vcfps2, vbfps2, vtdiblfps2, vdsatfps2;
real vgsfps3, vdsfps3, vcfps3, vbfps3, vtdiblfps3, vdsatfps3;
real vgsfps4, vdsfps4, vcfps4, vbfps4, vtdiblfps4, vdsatfps4;
real vgsfp1, vdsfp1, vcfp1, vbfp1, vtdiblfp1, vdsatfp1;
real vgsfp2, vdsfp2, vcfp2, vbfp2, vtdiblfp2, vdsatfp2;
real vgsfp3, vdsfp3, vcfp3, vbfp3, vtdiblfp3, vdsatfp3;
real vgsfp4, vdsfp4, vcfp4, vbfp4, vtdiblfp4, vdsatfp4;
real tambk, tnomk, tsh, tdut, tfacdiode, phit, pdiss;
real ids, idsrf, qgs, qgd, qc, qb, qs, igsi, igdi, igssdio, igdsdio, igsrec, igdrec;
real igsidb, igdidb, igssdiodb, igdsdiodb, igsrecdb, igdrecdb;
real igsi2, igdi2, igssdio2, igdsdio2, igsrec2, igdrec2;
real igsi2db, igdi2db, igssdio2db, igdsdio2db, igsrec2db, igdrec2db;
real vinscbd, vindcbd, igscbd, igdcbd, igscbddio, igdcbddio, igsrecbd, igdrecbd;
real idsrs,  qgsrs, qgdrs, qcrs, qbrs, qsrs;
real idsrd,  qgsrd, qgdrd, qcrd, qbrd, qsrd;
real idsfps1, qgsfps1, qgdfps1, qcfps1, qbfps1, qsfps1;
real idsfps2, qgsfps2, qgdfps2, qcfps2, qbfps2, qsfps2;
real idsfps3, qgsfps3, qgdfps3, qcfps3, qbfps3, qsfps3;
real idsfps4, qgsfps4, qgdfps4, qcfps4, qbfps4, qsfps4;
real idsfp1, qgsfp1, qgdfp1, qcfp1, qbfp1, qsfp1;
real idsfp2, qgsfp2, qgdfp2, qcfp2, qbfp2, qsfp2;
real idsfp3, qgsfp3, qgdfp3, qcfp3, qbfp3, qsfp3;
real idsfp4, qgsfp4, qgdfp4, qcfp4, qbfp4, qsfp4;
real qofs, qofd, qofds, qofdsub, qofssub, qofgsub;
real drsht, vtcollapse, vtcollapse0, ttrapfac;
real vdlinput, vdloutput, vglinput, vgloutput, chargefracd, chargefracg, chargefrac;
real gm, svc, fpwr;
real vsch, idsch, idschsat, idschrec, idsch2, idschsat2, idschrec2, rsch;
real qsch, qsch0, qsch1, qsch2, qsch3, qsch4, qsch5;
real qsch1c, qsch2c, qsch3c, qsch4c, qsch5c;
real vschfc1, vschfc2, vschfc3, vschfc4, vschfc5;

`OPP(vgisi,     "V",    "internal gate-source voltage")
`OPP(vdisi,     "V",    "internal drain-source voltage")
`OPP(vti,       "V",    "internal threshold voltage including DIBL")
`OPP(vdsati,    "V",    "internal drain-source saturation  voltage")
`OPM(pdc,       "W",    "total power dissipation from the device")
`OPM(idisi,     "A",    "drain-to-source current in intrinsic transistor")
`OPM(igs,       "A",    "gate-source gate-leakage current")
`OPM(igd,       "A",    "gate-drain gate-leakage current")
`OPM(qgi,       "C",    "intrinsic gate charge")
`OPM(qdi,       "C",    "intrinsic drain charge")
`OPM(qsi,       "C",    "intrinsic source charge")
`OPM(qbi,       "C",    "intrinsic body charge")
`OPM(gmi,       "A/V",  "intrinsic transconductance")
`OPM(gdsi,      "A/V",  "intrinsic output-conductance")
`OPM(gmbsi,     "A/V",  "intrinsic body-transconductance")
`OPM(cggi,      "F",    "intrinsic gate-gate capacitance")
`OPM(cgdi,      "F",    "intrinsic gate-drain capacitance")
`OPM(cgsi,      "F",    "intrinsic gate-source capacitance")
`OPM(cgbi,      "F",    "intrinsic gate-body capacitance")
`OPM(cdgi,      "F",    "intrinsic drain-gate capacitance")
`OPM(cddi,      "F",    "intrinsic drain-drain capacitance")
`OPM(cdsi,      "F",    "intrinsic drain-source capacitance")
`OPM(cdbi,      "F",    "intrinsic drain-body capacitance")
`OPM(csgi,      "F",    "intrinsic source-gate capacitance")
`OPM(csdi,      "F",    "intrinsic source-drain capacitance")
`OPM(cssi,      "F",    "intrinsic source-source capacitance")
`OPM(csbi,      "F",    "intrinsic source-body capacitance")
`OPM(cbgi,      "F",    "intrinsic body-gate capacitance")
`OPM(cbdi,      "F",    "intrinsic body-drain capacitance")
`OPM(cbsi,      "F",    "intrinsic body-source capacitance")
`OPM(cbbi,      "F",    "intrinsic body-body capacitance")
`OPM(cgs,       "F",    "gate-to-source fringing capacitance")
`OPM(cgd,       "F",    "gate-to-drain fringing capacitance")
`OPP(t_total_k, "K",    "actual device temperature in Kelvin")
`OPP(t_total_c, "deg C","actual device temperature in Celsius")
`OPP(t_delta_sh,"K",    "change in device temperature caused by self-heating")
`OPD(rs,        "Ohm",  "resistance of source access region")
`OPD(rd,        "Ohm",  "resistance of drain access region")

analog begin

    // Temperature dependence of voltage independent terms
    gmin               = $simparam("gmin",0);
    tnomk              = tnom + `P_CELSIUS0;
    tambk              = $temperature;

    // Make external thermal node dt optional
    if ($port_connected(dt) == 0);

    tsh                = Temp(dt);
    tdut               = tambk + dtemp + tsh;
    if (tdut < `T_MIN + `P_CELSIUS0) begin
        tdut            = `T_MIN + `P_CELSIUS0;
    end else begin
        if (tdut > `T_MAX + `P_CELSIUS0) begin
            tdut         = `T_MAX + `P_CELSIUS0;
        end
    end

    rsi                = 0;
    rdi                = 0;
    if (flagres==0) begin
        rcs_w           = rcs / w / ngf;
        rcd_w           = rcd / w / ngf;
    end else begin
        rcs_w           = ( rcs / w + rsh * lgs / w ) / ngf;
        rcd_w           = ( rcd / w + rsh * lgd / w ) / ngf;
    end
    if ((rcs_w >= minr) && (rcs_w > 0)) begin
        rsi             = ( rcs_w ) *  ( 1.0 + rct1 *  ( tdut - tnomk ) + rct2 *  ( tdut - tnomk ) *  ( tdut - tnomk ));
        if (rsi < 0.1 * rcs_w) begin
            rsi          = 0.1 * rcs_w;
        end
    end else begin
        rsi             = 0;
    end
    if ((rcd_w >= minr) && (rcd_w > 0)) begin
        rdi             = ( rcd_w ) *  ( 1.0 + rct1 *  ( tdut - tnomk ) + rct2 *  ( tdut - tnomk ) *  ( tdut - tnomk ));
        if (rdi < 0.1 * rcd_w) begin
            rdi          = 0.1 * rcd_w;
        end
    end else begin
        rdi             = 0;
    end
    rg1                 = ( rgsp / ngf / ngcon ) * ( lovg + agate * w / ngcon );
    rg2                 = ( rgsp / ngf / ngcon ) * ( (1.0 - agate) * w / ngcon );

    // Tempcos on key transport and charge parameters
    phit               = `P_KK * tdut / `P_QQ;
    ttrapfac           = 1.0 + tempt * ( tdut - tnomk );
    if (ttrapfac < 0.1) begin
        ttrapfac        = 0.1;
    end
    tfacdiode          = pow( ( tdut / tnomk ) , 3.0 );

    cofsmt             = calc_capt(cofsm,tcofs,tdut,tnomk);
    cofdmt             = calc_capt(cofdm,tcofd,tdut,tnomk);
    cofdsmt            = calc_capt(cofdsm,tcofds,tdut,tnomk);
    cofssubmt          = calc_capt(cofssubm,tcofssub,tdut,tnomk);
    cofdsubmt          = calc_capt(cofdsubm,tcofdsub,tdut,tnomk);
    cofgsubmt          = calc_capt(cofgsubm,tcofgsub,tdut,tnomk);
    cofsmt0            = calc_capt(cofsm0,tcofs,tdut,tnomk);
    cofdmt0            = calc_capt(cofdm0,tcofd,tdut,tnomk);
    cofdsmt0           = calc_capt(cofdsm0,tcofds,tdut,tnomk);
    cofssubmt0         = calc_capt(cofssubm0,tcofssub,tdut,tnomk);
    cofdsubmt0         = calc_capt(cofdsubm0,tcofdsub,tdut,tnomk);
    cofgsubmt0         = calc_capt(cofgsubm0,tcofgsub,tdut,tnomk);
    cgt                = calc_capt(cg,tcg,tdut,tnomk);
    cgfps1t            = calc_capt(cgfps1,tcgfps1,tdut,tnomk);
    cgfps2t            = calc_capt(cgfps2,tcgfps2,tdut,tnomk);
    cgfps3t            = calc_capt(cgfps3,tcgfps3,tdut,tnomk);
    cgfps4t            = calc_capt(cgfps4,tcgfps4,tdut,tnomk);
    ccfps1t            = calc_capt(ccfps1,tccfps1,tdut,tnomk);
    ccfps2t            = calc_capt(ccfps2,tccfps2,tdut,tnomk);
    ccfps3t            = calc_capt(ccfps3,tccfps3,tdut,tnomk);
    ccfps4t            = calc_capt(ccfps4,tccfps4,tdut,tnomk);
    cbfps1t            = calc_capt(cbfps1,tcbfps1,tdut,tnomk);
    cbfps2t            = calc_capt(cbfps2,tcbfps2,tdut,tnomk);
    cbfps3t            = calc_capt(cbfps3,tcbfps3,tdut,tnomk);
    cbfps4t            = calc_capt(cbfps4,tcbfps4,tdut,tnomk);
    cgfp1t             = calc_capt(cgfp1,tcgfp1,tdut,tnomk);
    cgfp2t             = calc_capt(cgfp2,tcgfp2,tdut,tnomk);
    cgfp3t             = calc_capt(cgfp3,tcgfp3,tdut,tnomk);
    cgfp4t             = calc_capt(cgfp4,tcgfp4,tdut,tnomk);
    ccfp1t             = calc_capt(ccfp1,tccfp1,tdut,tnomk);
    ccfp2t             = calc_capt(ccfp2,tccfp2,tdut,tnomk);
    ccfp3t             = calc_capt(ccfp3,tccfp3,tdut,tnomk);
    ccfp4t             = calc_capt(ccfp4,tccfp4,tdut,tnomk);
    cbfp1t             = calc_capt(cbfp1,tcbfp1,tdut,tnomk);
    cbfp2t             = calc_capt(cbfp2,tcbfp2,tdut,tnomk);
    cbfp3t             = calc_capt(cbfp3,tcbfp3,tdut,tnomk);
    cbfp4t             = calc_capt(cbfp4,tcbfp4,tdut,tnomk);

    // Determine drain-source and gate-source voltage for intrinsic transistor
    vdsi               = type * V(di,si);
    vgsi               = type * V(gi2p,si);

    // Determine drain-source and gate-source voltage for SAR transistor
    if (flaggum == 0) begin
        if (type * V(src, d) <= type * V(src, s)) begin
            vsars = type * V(src, s);
        end else begin
            vsars = type * V(src, d);
        end
    end else begin
        vsars          = mmax(type * V(src, d), type * V(src,s), mmaxs);
    end
    vigs               = vtors + 1.0 / (rsh * cgrs * mu0);
    vdsrs              = type * V(fps4,src);
    vgsrs              = (vigs - vsars);

    // Trapping module
    vtcollapse0        = 0;
    vtcollapse         = 0;
    drsht              = 1.0;
    vdlinput           = 0;
    vglinput           = 0;
    vdloutput          = 0;
    vgloutput          = 0;
    chargefracd        = 0;
    chargefracg        = 0;
    chargefrac         = 1.0;
    if ( trapselect    == 1) begin
        V(dtrapin)      <+0;
        V(dtrapin2)     <+0;
        V(dtrapin3)     <+0;
        V(gtrapin)      <+0;
        V(gtrapin2)     <+0;
        V(gtrapin3)     <+0;
        // Rsh degradation with trapping
        vtcollapse0     = alphat1 * abs(V(d,g)) + explim( (V(d,g) - vttrap - V(tr1) * alphat3) / alphat2 );
        I(tr1)          <+ -vtcollapse0;
        I(tr1)          <+ V(tr1)/rintrap1;
        I(tr1,tr)       <+ ddt(ctrap * V(tr1,tr));
        I(tr)           <+ ddt(taut * V(tr));
        I(tr)           <+ V(tr);
        vtcollapse      = V(tr);
        drsht           = 1.0 + (vtcollapse) * ttrapfac;
    end else if ( trapselect == 2) begin
        V(tr1)          <+0;
        V(tr)           <+0;
        // Drain-lag block
        V(dtrapin)      <+ type * V(d,s);
        vdlinput        = V(dtrapin);
        vdloutput       = V(dtrapin2);
        I(dtrapin3, dtrapin2)<+ isat * ( explim(V(dtrapin3, dtrapin2)/phit) - 1.0 );
        I(dtrapin, dtrapin3) <+ V(dtrapin, dtrapin3) / remission;
        I(dtrapin, dtrapin2) <+ V(dtrapin, dtrapin2) / rcapture;
        I(dtrapin2)     <+ cdglag * ddt(vdloutput) * ( 1.0 + rct1dl *  ( tdut - tnomk ) + rct2dl *  ( tdut - tnomk ) *  ( tdut - tnomk ));
        chargefracd     =  abs(vdloutput - vdlinput) / vdltrapth;
        // Gate-lag block
        V(gtrapin)      <+ type * V(g,s);
        vglinput        = V(gtrapin);
        vgloutput       = V(gtrapin2);
        I(gtrapin2, gtrapin3)<+ isat * ( explim(V(gtrapin2, gtrapin3)/phit) - 1.0 );
        I(gtrapin, gtrapin3) <+ V(gtrapin, gtrapin3) / remission;
        I(gtrapin, gtrapin2) <+ V(gtrapin, gtrapin2) / rcapture;
        I(gtrapin2)     <+ cdglag * ddt(vgloutput) * ( 1.0 + rct1gl *  ( tdut - tnomk ) + rct2gl *  ( tdut - tnomk ) *  ( tdut - tnomk ));
        chargefracg     =  abs(vgloutput - vglinput) / vgltrapth;
        chargefrac      = 1.0 / (1.0 + chargefracd + chargefracg);
    end else begin
        V(tr1)          <+0;
        V(tr)           <+0;
        V(dtrapin)      <+0;
        V(dtrapin2)     <+0;
        V(dtrapin3)     <+0;
        V(gtrapin)      <+0;
        V(gtrapin2)     <+0;
        V(gtrapin3)     <+0;
    end

    // Determine drain-source and gate-source voltage for DAR transistor
    if (flaggum == 0) begin
        if (type * V(fp4, d) <= type * V(fp4, s)) begin
            vdars = type * V(fp4, s);
        end else begin
            vdars = type * V(fp4, d);
        end
    end else begin
        vdars          = mmax(type * V(fp4, d), type * V(fp4, s), mmaxs);
    end
    vigd               = vtord + 1.0 / (drsht * rsh * cgrd * mu0);
    vdsrd              = type * V(drc,fp4);
    vgsrd              = (vigd - vdars);

    // Determine gate-source, drain-source voltage and cross-coupled voltages for FP transistors
    if (flagfps1 == 1) begin
        vgsfps1         = type * V(gi2,fps1);
        vcfps1          = type * V(s,fps1);
    end else begin
        vgsfps1         = type * V(s,fps1);
        vcfps1          = type * V(gi2,fps1);
    end
    vdsfps1            = type * V(si,fps1);
    vbfps1             = type * V(b,fps1);
    if (flagfps2 == 1) begin
        vgsfps2         = type * V(gi2,fps2);
        vcfps2          = type * V(s,fps2);
    end else begin
        vgsfps2         = type * V(s,fps2);
        vcfps2          = type * V(gi2,fps2);
    end
    vdsfps2            = type * V(fps1,fps2);
    vbfps2             = type * V(b,fps2);
    if (flagfps3 == 1) begin
        vgsfps3         = type * V(gi2,fps3);
        vcfps3          = type * V(s,fps3);
    end else begin
        vgsfps3         = type * V(s,fps3);
        vcfps3          = type * V(gi2,fps3);
    end
    vdsfps3            = type * V(fps2,fps3);
    vbfps3             = type * V(b,fps3);
    if (flagfps4 == 1) begin
        vgsfps4         = type * V(gi2,fps4);
        vcfps4          = type * V(s,fps4);
    end else begin
        vgsfps4         = type * V(s,fps4);
        vcfps4          = type * V(gi2,fps4);
    end
    vdsfps4            = type * V(fps3,fps4);
    vbfps4             = type * V(b,fps4);
    if (flagfp1 == 1) begin
        vgsfp1          = type * V(gi2,di);
        vcfp1           = type * V(s,di);
    end else begin
        vgsfp1          = type * V(s,di);
        vcfp1           = type * V(gi2,di);
    end
    vdsfp1             = type * V(fp1,di);
    vbfp1              = type * V(b,di);
    if (flagfp2 == 1) begin
        vgsfp2          = type * V(gi2,fp1);
        vcfp2           = type * V(s,fp1);
    end else begin
        vgsfp2          = type * V(s,fp1);
        vcfp2           = type * V(gi2,fp1);
    end
    vdsfp2             = type * V(fp2,fp1);
    vbfp2              = type * V(b,fp1);
    if (flagfp3 == 1) begin
        vgsfp3          = type * V(gi2,fp2);
        vcfp3           = type * V(s,fp2);
    end else begin
        vgsfp3          = type * V(s,fp2);
        vcfp3           = type * V(gi2,fp2);
    end
    vdsfp3             = type * V(fp3,fp2);
    vbfp3              = type * V(b,fp2);
    if (flagfp4 == 1) begin
        vgsfp4          = type * V(gi2,fp3);
        vcfp4           = type * V(s,fp3);
    end else begin
        vgsfp4          = type * V(s,fp3);
        vcfp4           = type * V(gi2,fp3);
    end
    vdsfp4             = type * V(fp4,fp3);
    vbfp4              = type * V(b,fp3);

    // current and charge calculations
    idsfp4             = 0;
    qgsfp4             = 0;
    qgdfp4             = 0;
    qcfp4              = 0;
    qbfp4              = 0;
    qsfp4              = 0;
    vtdiblfp4          = 0;
    vdsatfp4           = 0;
    if (lgfp4>(minl)) begin
        idsfp4          = calc_iq(idsfp4,qgsfp4,qgdfp4,qcfp4,qbfp4,qsfp4,vtdiblfp4,vdsatfp4,vgsfp4,vdsfp4,flagfp4b,vcfp4,vbfp4,flagfp4s,tdut,tnomk,phit,w,lgfp4,cgfp4t,cfp4s,ccfp4t,cbfp4t,vtofp4,sfp4,delta1fp4,0.0,ndfp4,alphafp4,vx0fp4,mu0fp4,betafp4,mthetafp4,vthetafp4,vtzetafp4,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);
        I(fp4,fp3)      <+ idsfp4 + gmin * V(fp4,fp3);
    end else begin
        V(fp4,fp3)      <+ 0;
    end
    if (flagfp4==1) begin
        I(gi2,fp3)      <+ ddt(qgsfp4) + ddt(minc * V(gi2,fp3));
        I(gi2,fp4)      <+ ddt(qgdfp4) + ddt(minc * V(gi2,fp4));
        I(s,fp3)        <+ ddt(qcfp4) + ddt(minc * V(s,fp3));
        I(s,fp4)        <+ 0;
        I(gi2,si)       <+ ddt(qsfp4) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fp3)        <+ ddt(qgsfp4) + ddt(minc * V(s,fp3));
        I(s,fp4)        <+ ddt(qgdfp4) + ddt(minc * V(s,fp4));
        I(gi2,fp3)      <+ ddt(qcfp4) + ddt(minc * V(gi2,fp3));
        I(gi2,fp4)      <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fp3)           <+ ddt(qbfp4) + ddt(minc * V(b,fp3));

    idsfp3             = 0;
    qgsfp3             = 0;
    qgdfp3             = 0;
    qcfp3              = 0;
    qbfp3              = 0;
    qsfp3              = 0;
    vtdiblfp3          = 0;
    vdsatfp3           = 0;
    if (lgfp3>(minl)) begin
        idsfp3          = calc_iq(idsfp3,qgsfp3,qgdfp3,qcfp3,qbfp3,qsfp3,vtdiblfp3,vdsatfp3,vgsfp3,vdsfp3,flagfp3b,vcfp3,vbfp3,flagfp3s,tdut,tnomk,phit,w,lgfp3,cgfp3t,cfp3s,ccfp3t,cbfp3t,vtofp3,sfp3,delta1fp3,0.0,ndfp3,alphafp3,vx0fp3,mu0fp3,betafp3,mthetafp3,vthetafp3,vtzetafp3,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);
        I(fp3,fp2)      <+ idsfp3 + gmin * V(fp3,fp2);
    end else begin
        V(fp3,fp2)      <+ 0;
    end
    if (flagfp3==1) begin
        I(gi2,fp2)      <+ ddt(qgsfp3) + ddt(minc * V(gi2,fp2));
        I(gi2,fp3)      <+ ddt(qgdfp3) + ddt(minc * V(gi2,fp3));
        I(s,fp2)        <+ ddt(qcfp3) + ddt(minc * V(s,fp2));
        I(s,fp3)        <+ 0;
        I(gi2,si)       <+ ddt(qsfp3) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fp2)        <+ ddt(qgsfp3) + ddt(minc * V(s,fp2));
        I(s,fp3)        <+ ddt(qgdfp3) + ddt(minc * V(s,fp3));
        I(gi2,fp2)      <+ ddt(qcfp3) + ddt(minc * V(gi2,fp2));
        I(gi2,fp3)      <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fp2)           <+ ddt(qbfp3) + ddt(minc * V(b,fp2));

    idsfp2             = 0;
    qgsfp2             = 0;
    qgdfp2             = 0;
    qcfp2              = 0;
    qbfp2              = 0;
    qsfp2              = 0;
    vtdiblfp2          = 0;
    vdsatfp2           = 0;
    if (lgfp2>(minl)) begin
        idsfp2          = calc_iq(idsfp2,qgsfp2,qgdfp2,qcfp2,qbfp2,qsfp2,vtdiblfp2,vdsatfp2,vgsfp2,vdsfp2,flagfp2b,vcfp2,vbfp2,flagfp2s,tdut,tnomk,phit,w,lgfp2,cgfp2t,cfp2s,ccfp2t,cbfp2t,vtofp2,sfp2,delta1fp2,0.0,ndfp2,alphafp2,vx0fp2,mu0fp2,betafp2,mthetafp2,vthetafp2,vtzetafp2,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);
        I(fp2,fp1)      <+ idsfp2 + gmin * V(fp2,fp1);
    end else begin
        V(fp2,fp1)      <+ 0;
    end
    if (flagfp2==1) begin
        I(gi2,fp1)      <+ ddt(qgsfp2) + ddt(minc * V(gi2,fp1));
        I(gi2,fp2)      <+ ddt(qgdfp2) + ddt(minc * V(gi2,fp2));
        I(s,fp1)        <+ ddt(qcfp2) + ddt(minc * V(s,fp1));
        I(s,fp2)        <+ 0;
        I(gi2,si)       <+ ddt(qsfp2) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fp1)        <+ ddt(qgsfp2) + ddt(minc * V(s,fp1));
        I(s,fp2)        <+ ddt(qgdfp2) + ddt(minc * V(s,fp2));
        I(gi2,fp1)      <+ ddt(qcfp2) + ddt(minc * V(gi2,fp1));
        I(gi2,fp2)      <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fp1)           <+ ddt(qbfp2) + ddt(minc * V(b,fp1));

    idsfp1             = 0;
    qgsfp1             = 0;
    qgdfp1             = 0;
    qcfp1              = 0;
    qbfp1              = 0;
    qsfp1              = 0;
    vtdiblfp1          = 0;
    vdsatfp1           = 0;
    if (lgfp1>(minl)) begin
        idsfp1          = calc_iq(idsfp1,qgsfp1,qgdfp1,qcfp1,qbfp1,qsfp1,vtdiblfp1,vdsatfp1,vgsfp1,vdsfp1,flagfp1b,vcfp1,vbfp1,flagfp1s,tdut,tnomk,phit,w,lgfp1,cgfp1t,cfp1s,ccfp1t,cbfp1t,vtofp1,sfp1,delta1fp1,0.0,ndfp1,alphafp1,vx0fp1,mu0fp1,betafp1,mthetafp1,vthetafp1,vtzetafp1,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);

        I(fp1,di)       <+ idsfp1 + gmin * V(fp1,di);
    end else begin
        V(fp1,di)       <+ 0;
    end
    if (flagfp1==1) begin
        I(gi2,di)       <+ ddt(qgsfp1) + ddt(minc * V(gi2,di));
        I(gi2,fp1)      <+ ddt(qgdfp1) + ddt(minc * V(gi2,fp1));
        I(s,di)         <+ ddt(qcfp1) + ddt(minc * V(s,di));
        I(s,fp1)        <+ 0;
        I(gi2,si)       <+ ddt(qsfp1) + ddt(minc * V(gi2,si));
    end else begin
        I(s,di)         <+ ddt(qgsfp1) + ddt(minc * V(s,di));
        I(s,fp1)        <+ ddt(qgdfp1) + ddt(minc * V(s,fp1));
        I(gi2,di)       <+ ddt(qcfp1) + ddt(minc * V(gi2,di));
        I(gi2,fp1)      <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,di)            <+ ddt(qbfp1) + ddt(minc * V(b,di));


    idsfps1            = 0;
    qgsfps1            = 0;
    qgdfps1            = 0;
    qcfps1             = 0;
    qbfps1             = 0;
    qsfps1             = 0;
    vtdiblfps1         = 0;
    vdsatfps1          = 0;
    if (lgfps1>(minl)) begin
        idsfps1         = calc_iq(idsfps1,qgsfps1,qgdfps1,qcfps1,qbfps1,qsfps1,vtdiblfps1,vdsatfps1,vgsfps1,vdsfps1,flagfps1b,vcfps1,vbfps1,flagfps1s,tdut,tnomk,phit,w,lgfps1,cgfps1t,cfps1s,ccfps1t,cbfps1t,vtofps1,sfps1,delta1fps1,0.0,ndfps1,alphafps1,vx0fps1,mu0fps1,betafps1,mthetafps1,vthetafps1,vtzetafps1,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);

        I(si,fps1)      <+ idsfps1 + gmin * V(si,fps1);
    end else begin
        V(si,fps1)      <+ 0;
    end
    if (flagfps1==1) begin
        I(gi2,fps1)     <+ ddt(qgsfps1) + ddt(minc * V(gi2,fps1));
        I(gi2,si)       <+ ddt(qgdfps1) + ddt(minc * V(gi2,si));
        I(s,fps1)       <+ ddt(qcfps1) + ddt(minc * V(s,fps1));
        I(s,si)         <+ 0;
        I(gi2,si)       <+ ddt(qsfps1) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fps1)       <+ ddt(qgsfps1) + ddt(minc * V(s,fps1));
        I(s,si)         <+ ddt(qgdfps1) + ddt(minc * V(s,si));
        I(gi2,fps1)     <+ ddt(qcfps1) + ddt(minc * V(gi2,fps1));
        I(gi2,si)       <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fps1)          <+ ddt(qbfps1) + ddt(minc * V(b,fps1));

    idsfps2            = 0;
    qgsfps2            = 0;
    qgdfps2            = 0;
    qcfps2             = 0;
    qbfps2             = 0;
    qsfps2             = 0;
    vtdiblfps2         = 0;
    vdsatfps2          = 0;
    if (lgfps2>(minl)) begin
        idsfps2         = calc_iq(idsfps2,qgsfps2,qgdfps2,qcfps2,qbfps2,qsfps2,vtdiblfps2,vdsatfps2,vgsfps2,vdsfps2,flagfps2b,vcfps2,vbfps2,flagfps2s,tdut,tnomk,phit,w,lgfps2,cgfps2t,cfps2s,ccfps2t,cbfps2t,vtofps2,sfps2,delta1fps2,0.0,ndfps2,alphafps2,vx0fps2,mu0fps2,betafps2,mthetafps2,vthetafps2,vtzetafps2,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);

        I(fps1,fps2)    <+ idsfps2 + gmin * V(fps1,fps2);
    end else begin
        V(fps1,fps2)    <+ 0;
    end
    if (flagfps2==1) begin
        I(gi2,fps2)     <+ ddt(qgsfps2) + ddt(minc * V(gi2,fps2));
        I(gi2,fps1)     <+ ddt(qgdfps2) + ddt(minc * V(gi2,fps1));
        I(s,fps2)       <+ ddt(qcfps2) + ddt(minc * V(s,fps2));
        I(s,fps1)       <+ 0;
        I(gi2,si)       <+ ddt(qsfps2) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fps2)       <+ ddt(qgsfps2) + ddt(minc * V(s,fps2));
        I(s,fps1)       <+ ddt(qgdfps2) + ddt(minc * V(s,fps1));
        I(gi2,fps2)     <+ ddt(qcfps2) + ddt(minc * V(gi2,fps2));
        I(gi2,fps1)     <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fps2)          <+ ddt(qbfps2) + ddt(minc * V(b,fps2));

    idsfps3            = 0;
    qgsfps3            = 0;
    qgdfps3            = 0;
    qcfps3             = 0;
    qbfps3             = 0;
    qsfps3             = 0;
    vtdiblfps3         = 0;
    vdsatfps3          = 0;
    if (lgfps3>(minl)) begin
        idsfps3         = calc_iq(idsfps3,qgsfps3,qgdfps3,qcfps3,qbfps3,qsfps3,vtdiblfps3,vdsatfps3,vgsfps3,vdsfps3,flagfps3b,vcfps3,vbfps3,flagfps3s,tdut,tnomk,phit,w,lgfps3,cgfps3t,cfps3s,ccfps3t,cbfps3t,vtofps3,sfps3,delta1fps3,0.0,ndfps3,alphafps3,vx0fps3,mu0fps3,betafps3,mthetafps3,vthetafps3,vtzetafps3,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);

        I(fps2,fps3)    <+ idsfps3 + gmin * V(fps2,fps3);
    end else begin
        V(fps2,fps3)    <+ 0;
    end
    if (flagfps3==1) begin
        I(gi2,fps3)     <+ ddt(qgsfps3) + ddt(minc * V(gi2,fps3));
        I(gi2,fps2)     <+ ddt(qgdfps3) + ddt(minc * V(gi2,fps2));
        I(s,fps3)       <+ ddt(qcfps3) + ddt(minc * V(s,fps3));
        I(s,fps2)       <+ 0;
        I(gi2,si)       <+ ddt(qsfps3) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fps3)       <+ ddt(qgsfps3) + ddt(minc * V(s,fps3));
        I(s,fps2)       <+ ddt(qgdfps3) + ddt(minc * V(s,fps2));
        I(gi2,fps3)     <+ ddt(qcfps3) + ddt(minc * V(gi2,fps3));
        I(gi2,fps2)     <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fps3)          <+ ddt(qbfps3) + ddt(minc * V(b,fps3));

    idsfps4            = 0;
    qgsfps4            = 0;
    qgdfps4            = 0;
    qcfps4             = 0;
    qbfps4             = 0;
    qsfps4             = 0;
    vtdiblfps4         = 0;
    vdsatfps4          = 0;
    if (lgfps4>(minl)) begin
        idsfps4         = calc_iq(idsfps4,qgsfps4,qgdfps4,qcfps4,qbfps4,qsfps4,vtdiblfps4,vdsatfps4,vgsfps4,vdsfps4,flagfps4b,vcfps4,vbfps4,flagfps4s,tdut,tnomk,phit,w,lgfps4,cgfps4t,cfps4s,ccfps4t,cbfps4t,vtofps4,sfps4,delta1fps4,0.0,ndfps4,alphafps4,vx0fps4,mu0fps4,betafps4,mthetafps4,vthetafps4,vtzetafps4,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);

        I(fps3,fps4)    <+ idsfps4 + gmin * V(fps3,fps4);
    end else begin
        V(fps3,fps4)    <+ 0;
    end
    if (flagfps4==1) begin
        I(gi2,fps4)     <+ ddt(qgsfps4) + ddt(minc * V(gi2,fps4));
        I(gi2,fps3)     <+ ddt(qgdfps4) + ddt(minc * V(gi2,fps3));
        I(s,fps4)       <+ ddt(qcfps4) + ddt(minc * V(s,fps4));
        I(s,fps3)       <+ 0;
        I(gi2,si)       <+ ddt(qsfps4) + ddt(minc * V(gi2,si));
    end else begin
        I(s,fps4)       <+ ddt(qgsfps4) + ddt(minc * V(s,fps4));
        I(s,fps3)       <+ ddt(qgdfps4) + ddt(minc * V(s,fps3));
        I(gi2,fps4)     <+ ddt(qcfps4) + ddt(minc * V(gi2,fps4));
        I(gi2,fps3)     <+ 0;
        I(gi2,si)       <+ 0;
    end
    I(b,fps4)          <+ ddt(qbfps4) + ddt(minc * V(b,fps4));

    idsrs              = 0;
    qgsrs              = 0;
    qgdrs              = 0;
    qcrs               = 0;
    qbrs               = 0;
    qsrs               = 0;
    vtdiblrs           = 0;
    vdsatrs            = 0;
    if (flagres==0 && lgs>(minl)) begin
        idsrs           = calc_iq(idsrs,qgsrs,qgdrs,qcrs,qbrs,qsrs,vtdiblrs,vdsatrs,vgsrs,vdsrs,0,0,0,0,tdut,tnomk,phit,w,lgs,cgrs,0,0,0,vtors,srs,delta1rs,0.0,ndrs,alphars,vx0rs,mu0rs,betars,mthetars,vthetars,vtzeta,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);
        I(fps4,src)     <+ idsrs + gmin * V(fps4,src);
    end else begin
        V(fps4,src)     <+ 0;
    end

    idsrd              = 0;
    qgsrd              = 0;
    qgdrd              = 0;
    qcrd               = 0;
    qbrd               = 0;
    qsrd               = 0;
    vtdiblrd           = 0;
    vdsatrd            = 0;
    if (flagres==0 && lgd>(minl)) begin
        idsrd              = calc_iq(idsrd,qgsrd,qgdrd,qcrd,qbrd,qsrd,vtdiblrd,vdsatrd,vgsrd,vdsrd,0,0,0,0,tdut,tnomk,phit,w,lgd,cgrd,0,0,0,vtord,srd,delta1rd,0.0,ndrd,alphard,vx0rd,mu0rd,betard,mthetard,vthetard,vtzeta,dibsat,epsilon,vzeta,lambda,ngf,type,1.0);
        I(drc,fp4)      <+ idsrd + gmin * V(drc,fp4);
    end else begin
        V(drc,fp4)      <+ 0;
    end

    ids                = calc_iq(ids,qgs,qgd,qc,qb,qs,vtdibli,vdsat1i,vgsi,vdsi,0,0,0,0,tdut,tnomk,phit,w,l,cgt,0,0,0,vto,ss,delta1,delta2,nd,alpha,vx0,mu0,beta,mtheta,vtheta,vtzeta,dibsat,epsilon,vzeta,lambda,ngf,type,chargefrac);

    // channel-gm-dispersion calculations
    idsrf              = V(xt2);
    if (gmdisp==0) begin
        V(xt1)          <+ 0;
        V(xt2)          <+ 0;
        I(di,si)        <+ ids + gmin * V(di,si);
    end else begin
        I(xt1)          <+ ids - V(xt2) - ddt(taugmrf * V(xt1));
        I(xt2)          <+ V(xt1) - V(xt2) - ddt((taugmrf/3.0) * V(xt2));
        I(di,si)        <+ idsrf + gmin * V(di,si);
    end
    I(gi2p,si)          <+ ddt(qgs) + ddt(minc * V(gi2p,si));
    I(gi2p,di)          <+ ddt(qgd) + ddt(minc * V(gi2p,di));

    // gate-current calculations
    igsi               = 0;
    igdi               = 0;
    igssdio            = 0;
    igdsdio            = 0;
    igsrec             = 0;
    igdrec             = 0;
    igsi2              = 0;
    igdi2              = 0;
    igssdio2           = 0;
    igdsdio2           = 0;
    igsrec2            = 0;
    igdrec2            = 0;
    igsidb             = 0;
    igdidb             = 0;
    igssdiodb          = 0;
    igdsdiodb          = 0;
    igsrecdb           = 0;
    igdrecdb           = 0;
    igsi2db            = 0;
    igdi2db            = 0;
    igssdio2db         = 0;
    igdsdio2db         = 0;
    igsrec2db          = 0;
    igdrec2db          = 0;
    if (igmod == 1) begin
        igsi            = calc_ig(igssdio,igsrec,type * V(gi2p, fps4),phit,vgsats,alphags,fracs,pg_params,pbdgs,vbdgs,tfacdiode,w,ngf,(1.0 - fracig) * ijs,kbdgates,vgsatqs,betarecs,(1.0 - fracig) * irecs,pgsrecs,pg_param1,vjg,type);
        igdi            = calc_ig(igdsdio,igdrec,type * V(gi2p, fp4),phit,vgsatd,alphagd,fracd,pg_paramd,pbdgd,vbdgd,tfacdiode,w,ngf,(1.0 - fracig) * ijd,kbdgated,vgsatqd,betarecd,(1.0 - fracig) * irecd,pgsrecd,pg_param1,vjg,type);
        I(gi2p,fps4)     <+ igsi + gmin * V(gi2p,fps4);
        I(gi2p,fp4)      <+ igdi + gmin * V(gi2p,fp4);
        if (igrecmod == 1) begin
            igsi2       = calc_ig(igssdio2,igsrec2,type * V(gi2p, fps4),phit,vgsats,alphags,1.0,pg_params,pbdgs,vbdgs,tfacdiode,w,ngf,0.0,0.0,vgsatqs2,betarecs2,(1.0 - fracig) * irecs2,pgsrecs2,pg_param1,vjg,type);
            igdi2       = calc_ig(igdsdio2,igdrec2,type * V(gi2p, fp4),phit,vgsatd,alphagd,1.0,pg_paramd,pbdgd,vbdgd,tfacdiode,w,ngf,0.0,0.0,vgsatqd2,betarecd2,(1.0 - fracig) * irecd2,pgsrecd2,pg_param1,vjg,type);
            I(gi2p,fps4) <+ igsi2 + gmin * V(gi2p,fps4);
            I(gi2p,fp4)  <+ igdi2 + gmin * V(gi2p,fp4);
        end
        if (fracig   != 0) begin
            igsidb      = calc_ig(igssdiodb,igsrecdb,type * V(gi2p, si),phit,vgsats,alphags,fracs,pg_params,pbdgs,vbdgs,tfacdiode,w,ngf,fracig * ijs,kbdgates,vgsatqs,betarecs,fracig * irecs,pgsrecs,pg_param1,vjg,type);
            igdidb      = calc_ig(igdsdiodb,igdrecdb,type * V(gi2p, di),phit,vgsatd,alphagd,fracd,pg_paramd,pbdgd,vbdgd,tfacdiode,w,ngf,fracig * ijd,kbdgated,vgsatqd,betarecd,fracig * irecd,pgsrecd,pg_param1,vjg,type);
            I(gi2p,si)   <+ igsidb + gmin * V(gi2p,si);
            I(gi2p,di)   <+ igdidb + gmin * V(gi2p,di);
            if (igrecmod == 1) begin
                igsi2db = calc_ig(igssdio2db,igsrec2db,type * V(gi2p, si),phit,vgsats,alphags,1.0,pg_params,pbdgs,vbdgs,tfacdiode,w,ngf,0.0,0.0,vgsatqs2,betarecs2,fracig * irecs2,pgsrecs2,pg_param1,vjg,type);
                igdi2db = calc_ig(igdsdio2db,igdrec2db,type * V(gi2p, di),phit,vgsatd,alphagd,1.0,pg_paramd,pbdgd,vbdgd,tfacdiode,w,ngf,0.0,0.0,vgsatqd2,betarecd2,fracig * irecd2,pgsrecd2,pg_param1,vjg,type);
                I(gi2p,si)<+ igsi2db + gmin * V(gi2p,si);
                I(gi2p,di)<+ igdi2db + gmin * V(gi2p,di);
            end
        end
    end

    //p-Gan current and charge calculations
    vsch               = 0;
    idsch              = 0;
    idschsat           = 0;
    idschrec           = 0;
    idsch2             = 0;
    idschsat2          = 0;
    idschrec2          = 0;
    qsch               = 0;
    qsch0              = 0;
    qsch1              = 0;
    qsch2              = 0;
    qsch3              = 0;
    qsch4              = 0;
    qsch5              = 0;
    vschfc1            = 0;
    vschfc2            = 0;
    vschfc3            = 0;
    vschfc4            = 0;
    vschfc5            = 0;
    rsch               = 0;
    if (flagpgan == 1) begin
        vsch           = type * V(gi2p,gi2);
        idsch          = calc_ig(idschsat,idschrec,vsch,phit,vgsat_pgan,alphag_pgan,frac_pgan,pg_param_pgan,4.0,600.0,tfacdiode,w * (1.0-ohmicratio),ngf,ij_pgan,0.0,vgsatq_pgan,betarec_pgan,irec_pgan,pgsrec_pgan,0.0,0.0,type);
        I(gi2p,gi2)    <+ idsch + gmin * V(gi2p,gi2);
        if (pganrecmod == 1) begin
            idsch2     = calc_ig(idschsat2,idschrec2,vsch,phit,1.0,10.0,1.0,0.0,4.0,600.0,tfacdiode,w * (1.0-ohmicratio),ngf,0.0,0.0,vgsatq_pgan2,betarec_pgan2,irec_pgan2,pgsrec_pgan2,0.0,0.0,type);
            I(gi2p,gi2)<+ idsch2 + gmin * V(gi2p,gi2);
        end
        if (vsch <= fc * vcsh0) begin
            qsch       = type * 2.0 * csh0 * w * (1.0-ohmicratio) * ngf * vcsh0 * ( 1.0 - sqrt( 1.0 - vsch/vcsh0 ) );
        end else begin
            qsch0      = 1.0 - sqrt( 1.0 - fc );
            if (pgancshorder >= 1) begin
                qsch1c  = 1.0 / ( 2.0 * vcsh0 * sqrt(1.0-fc) );
                vschfc1 = vsch - fc * vcsh0;
                qsch1   = qsch1c * vschfc1;
                if (pgancshorder >= 2) begin
                    qsch2c  = qsch1c / ( 4.0 * vcsh0 * (1.0-fc) );
                    vschfc2 = vschfc1 * vschfc1;
                    qsch2   = qsch2c * vschfc2;
                    if (pgancshorder >= 3) begin
                        qsch3c  = qsch2c / ( 2.0 * vcsh0 * (1.0-fc) );
                        vschfc3 = vschfc2 * vschfc1;
                        qsch3   = qsch3c * vschfc3;
                        if (pgancshorder >= 4) begin
                            qsch4c  = 5.0 * qsch3c / ( 8.0 * vcsh0 * (1.0-fc) );
                            vschfc4 = vschfc3 * vschfc1;
                            qsch4   = qsch4c * vschfc4;
                            if (pgancshorder >= 5) begin
                                qsch5c  = 7.0 * qsch4c / ( 10.0 * vcsh0 * (1.0-fc) );
                                vschfc5 = vschfc4 * vschfc1;
                                qsch5   = qsch5c * vschfc5;
                            end else begin
                                qsch5c  = 0;
                            end
                        end else begin
                            qsch4c  = 0;
                        end
                    end else begin
                        qsch3c  = 0;
                    end
                end else begin
                    qsch2c  = 0;
                end
            end else begin
                qsch1c  = 0;
            end
            qsch       = type * 2.0 * csh0 * w * (1.0-ohmicratio) * ngf * vcsh0 * ( qsch0 + qsch1 + qsch2 + qsch3 + qsch4 + qsch5 );
        end
        I(gi2p,gi2)    <+ ddt(qsch);
        if (rsch0 !=0 && ohmicratio != 0) begin
            rsch       = rsch0 / ( w * ohmicratio * ngf );
            I(gi2p,gi2)<+ V(gi2p,gi2) / rsch;
        end
    end else begin
        V(gi2,gi2p)    <+ 0;
    end

    // channel-breakdown current calculations
    igscbd             = 0;
    igdcbd             = 0;
    igscbddio          = 0;
    igdcbddio          = 0;
    igsrecbd           = 0;
    igdrecbd           = 0;
    vinscbd            = type * ( V(src,drc) + V(src,gi2p) );
    vindcbd            = type * ( V(drc,src) + V(drc,gi2p) );
    if (icbdmod == 1) begin
        if (cbddbmod == 0) begin
            vinscbd      = type * ( V(s,d) + V(s,gi2p) );
            vindcbd      = type * ( V(d,s) + V(d,gi2p) );
        end
        igscbd          = calc_ig(igscbddio,igsrecbd,vinscbd,phit,vgsats,alphags,fracs,0,pchbdgs,vchbdgs,tfacdiode,w,ngf,ijscbd,1.0,vgsatqs,betarecs,0,pgsrecs,0,vjg,type);
        igdcbd          = calc_ig(igdcbddio,igdrecbd,vindcbd,phit,vgsatd,alphagd,fracd,0,pchbdgd,vchbdgd,tfacdiode,w,ngf,ijdcbd,1.0,vgsatqd,betarecd,0,pgsrecd,0,vjg,type);
        if (cbddbmod == 0) begin
            I(s,d)       <+ igscbd;
            I(d,s)       <+ igdcbd;
        end else begin
            I(src,drc)   <+ igscbd;
            I(drc,src)   <+ igdcbd;
        end
    end

    // resistors
    if ((rcd_w >= minr) && (rcd_w > 0)) begin
        I(d,drc)        <+ V(d,drc) / rdi;
    end else begin
        V(d,drc)        <+ 0;
    end
    if ((rcs_w >= minr) && (rcs_w > 0)) begin
        I(src,s)        <+ V(src,s) / rsi;
    end else begin
        V(src,s)        <+ 0;
    end
    if ((rg1 >= minr) && (rg1 > 0)) begin
        I(g,gi1)        <+ V(g,gi1) / rg1;
    end else begin
        V(g,gi1)        <+ 0;
    end
    if ((rg2 >= minr) && (rg2 > 0)) begin
        I(gi1,gi2)      <+ V(gi1,gi2) / rg2;
    end else begin
        V(gi1,gi2)      <+ 0;
    end

    // Fringing capacitances
    if (((V(gi1,s) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofs            = w * ngf * (cofsmt0 * V(gi1,s) + cofsmt * (V(gi1,s) - vtfrin));
    end else if (((V(gi1,s) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofs            = w * ngf * (cofsmt0 * V(gi1,s) + cofsmt * nfrin * exp( (V(gi1,s) - vtfrin) / nfrin));
    end else begin
        qofs            = w * ngf * (cofsmt0 * V(gi1,s) + cofsmt * nfrin * ln( 1.0 + exp( (V(gi1,s) - vtfrin) / nfrin)));
    end
    I(gi1,s)           <+ ddt(qofs);

    if (((V(gi1,d) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofd            = w * ngf * (cofdmt0 * V(gi1,d) + cofdmt * (V(gi1,d) - vtfrin));
    end else if (((V(gi1,d) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofd            = w * ngf * (cofdmt0 * V(gi1,d) + cofdmt * nfrin * exp( (V(gi1,d) - vtfrin) / nfrin));
    end else begin
        qofd            = w * ngf * (cofdmt0 * V(gi1,d) + cofdmt * nfrin * ln( 1.0 + exp( (V(gi1,d) - vtfrin) / nfrin)));
    end
    I(gi1,d)           <+ ddt(qofd);

    if (((V(s,d) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofds           = w * ngf * (cofdsmt0 * V(s,d) + cofdsmt * (V(s,d) - vtfrin));
    end else if (((V(s,d) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofds           = w * ngf * (cofdsmt0 * V(s,d) + cofdsmt * nfrin * exp( (V(s,d) - vtfrin) / nfrin));
    end else begin
        qofds           = w * ngf * (cofdsmt0 * V(s,d) + cofdsmt * nfrin * ln( 1.0 + exp( (V(s,d) - vtfrin) / nfrin)));
    end
    I(s,d)             <+ ddt(qofds);

    if (((V(b,s) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofssub         = w * ngf * (cofssubmt0 * V(b,s) + cofssubmt * (V(b,s) - vtfrin));
    end else if (((V(b,s) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofssub         = w * ngf * (cofssubmt0 * V(b,s) + cofssubmt * nfrin * exp( (V(b,s) - vtfrin) / nfrin));
    end else begin
        qofssub         = w * ngf * (cofssubmt0 * V(b,s) + cofssubmt * nfrin * ln( 1.0 + exp( (V(b,s) - vtfrin) / nfrin)));
    end
    I(b,s)             <+ ddt(qofssub);

    if (((V(b,d) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofdsub         = w * ngf * (cofdsubmt0 * V(b,d) + cofdsubmt * (V(b,d) - vtfrin));
    end else if (((V(b,d) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofdsub         = w * ngf * (cofdsubmt0 * V(b,d) + cofdsubmt * nfrin * exp( (V(b,d) - vtfrin) / nfrin));
    end else begin
        qofdsub         = w * ngf * (cofdsubmt0 * V(b,d) + cofdsubmt * nfrin * ln( 1.0 + exp( (V(b,d) - vtfrin) / nfrin)));
    end
    I(b,d)             <+ ddt(qofdsub);

    if (((V(gi1,b) - vtfrin) / nfrin) > `M_MAXEXP) begin
        qofgsub         = w * ngf * (cofgsubmt0 * V(gi1,b) + cofgsubmt * (V(gi1,b) - vtfrin));
    end else if (((V(gi1,b) - vtfrin) / nfrin) < -`M_MAXEXP) begin
        qofgsub         = w * ngf * (cofgsubmt0 * V(gi1,b) + cofgsubmt * nfrin * exp( (V(gi1,b) - vtfrin) / nfrin));
    end else begin
        qofgsub         = w * ngf * (cofgsubmt0 * V(gi1,b) + cofgsubmt * nfrin * ln( 1.0 + exp( (V(gi1,b) - vtfrin) / nfrin)));
    end
    I(gi1,b)           <+ ddt(qofgsub);

    // noise calculations
    gm                 = 0;
    svc                = 0;
    if (noisemod == 1) begin
        I(gi2p,si)       <+ white_noise(shs * `P_QQ * abs(igsidb + 2.0 * (igssdiodb + igsrecdb)), "g-s shot int");
        I(gi2p,di)       <+ white_noise(shd * `P_QQ * abs(igdidb + 2.0 * (igdsdiodb + igdrecdb)), "g-d shot int");

        I(gi2p,fps4)     <+ white_noise(shs * `P_QQ * abs(igsi + 2.0 * (igssdio + igsrec)), "g-s shot ext");
        I(gi2p,fp4)      <+ white_noise(shd * `P_QQ * abs(igdi + 2.0 * (igdsdio + igdrec)), "g-d shot ext");

        fpwr            = kf * ( w * ngf / l ) * pow( ( abs(ids) / ( w * ngf ) ), af);
        if (ids <0) begin
            fpwr         = -fpwr;
        end
        I(di,si)        <+ flicker_noise(fpwr, ffe, "flicker");

        gm              = ddx(ids , V(gi2p));
        svc             = 4.0 * `P_KK * tdut * gm * ( qgs + qgd ) / ( w * ngf * l * type * cg );
        I(di,si)        <+ white_noise(svc, "channel");

        if (lgfps1>(minl) && rsh!=0) begin
            I(si,fps1)   <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfps1 / ( w * ngf )), "rfps1");
        end
        if (lgfps2>(minl) && rsh!=0) begin
            I(fps1,fps2) <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfps2 / ( w * ngf )), "rfps2");
        end
        if (lgfps3>(minl) && rsh!=0) begin
            I(fps2,fps3) <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfps3 / ( w * ngf )), "rfps3");
        end
        if (lgfps4>(minl) && rsh!=0) begin
            I(fps3,fps4) <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfps4 / ( w * ngf )), "rfps4");
        end
        if (lgfp1>(minl) && rsh!=0) begin
            I(fp1,di)    <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfp1 / ( w * ngf )), "rfp1");
        end
        if (lgfp2>(minl) && rsh!=0) begin
            I(fp2,fp1)   <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfp2 / ( w * ngf )), "rfp2");
        end
        if (lgfp3>(minl) && rsh!=0) begin
            I(fp3,fp2)   <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfp3 / ( w * ngf )), "rfp3");
        end
        if (lgfp4>(minl) && rsh!=0) begin
            I(fp4,fp3)   <+ white_noise(4.0 * `P_KK * tdut / (rsh * lgfp4 / ( w * ngf )), "rfp4");
        end
        if ((rcs_w >= minr) && (rcs_w > 0)) begin
            I(src,s)     <+ white_noise(4.0 * `P_KK * tdut / rsi, "rcs");
        end
        if ((rcd_w >= minr) && (rcd_w > 0)) begin
            I(d,drc)     <+ white_noise(4.0 * `P_KK * tdut / rdi, "rcd");
        end
    end

    // power-dissipation calculations
    pdiss              = ( ids * V(di,si) + idsrd * V(drc,fp4) + idsrs * V(fps4,src) + idsfps4 * V(fps3,fps4) + idsfps3 * V(fps2,fps3) + idsfps2 * V(fps1,fps2) + idsfps1 * V(si,fps1) + idsfp1 * V(fp1,di) + idsfp2 * V(fp2,fp1) + idsfp3 * V(fp3,fp2) + idsfp4 * V(fp4,fp3) );
    if ((rcd_w >= minr) && (rcd_w > 0)) begin
        pdiss           = pdiss + ( V(drc,d) * V(drc,d) / rdi );
    end
    if ((rcs_w >= minr) && (rcs_w > 0)) begin
        pdiss           = pdiss + ( V(src,s) * V(src,s) / rsi );
    end
    // Self-heating
    if (rth >0) begin
        Pwr(dt)         <+ ddt( cth  * Temp(dt));
        Pwr(dt)         <+ - pdiss;
        Pwr(dt)         <+ Temp(dt) / rth;
    end else begin
        Temp(dt)        <+  0.0;
    end

    // OP-point variables
    vgisi              = V(gi2p,si);
    vdisi              = V(di,si);
    vti                = vtdibli;
    vdsati             = vdsat1i;
    pdc                = pdiss;
    idisi              = ids;
    igs                = igsi;
    igd                = igdi;
    qgi                = qgs + qgd;
    qdi                = -qgd;
    qsi                = -qgs;
    qbi                = 0;
    gmi                = ddx(ids , V(gi2p));
    gdsi               = ddx(ids , V(di));
    gmbsi              = ddx(ids , V(b));
    cggi               = ddx(qgi, V(gi2p));
    cgdi               = ddx(qgi, V(di));
    cgsi               = ddx(qgi, V(si));
    cgbi               = ddx(qgi, V(b));
    cdgi               = ddx(qdi, V(gi2p));
    cddi               = ddx(qdi, V(di));
    cdsi               = ddx(qdi, V(si));
    cdbi               = ddx(qdi, V(b));
    csgi               = ddx(qsi, V(gi2p));
    csdi               = ddx(qsi, V(di));
    cssi               = ddx(qsi, V(si));
    csbi               = ddx(qsi, V(b));
    cbgi               = ddx(qbi, V(gi2p));
    cbdi               = ddx(qbi, V(di));
    cbsi               = ddx(qbi, V(si));
    cbbi               = ddx(qbi, V(b));
    cgs                = w * ngf * cofsm;
    cgd                = w * ngf * cofdm;
    t_total_k          = tdut;
    t_total_c          = tdut - `P_CELSIUS0;
    t_delta_sh         = tsh;
    rs                 = ( rsh * lgs / w ) / ngf;
    rd                 = ( rsh * lgd / w ) / ngf;

end

endmodule

